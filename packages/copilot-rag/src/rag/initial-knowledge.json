{
  "metadata": {
    "version": "0.4.0",
    "generatedAt": "2025-11-22T04:39:00.026Z",
    "documentCount": 40,
    "stratixVersion": "0.4.0",
    "statistics": {
      "docs": 35,
      "api": 5
    },
    "sources": {
      "docusaurus": 35,
      "packages": 5,
      "patterns": 0,
      "examples": 0
    }
  },
  "documents": [
    {
      "id": "docs-ai-agents-agent-memory",
      "content": "\n# Agent Memory\n\nManage conversation history and context for AI agents.\n\n## Memory Store Interface\n\n```typescript\ninterface AgentMemory {\n  addMessage(agentId: string, message: AgentMessage): Promise<void>;\n  getMessages(agentId: string, limit?: number): Promise<AgentMessage[]>;\n  clearMessages(agentId: string): Promise<void>;\n}\n```\n\n## In-Memory Storage\n\n```typescript\nimport { InMemoryAgentMemory } from '@stratix/runtime';\n\nconst memory = new InMemoryAgentMemory();\n\n// Add message\nawait memory.addMessage('agent-123', {\n  role: 'user',\n  content: 'Hello!',\n  timestamp: new Date()\n});\n\n// Get messages\nconst messages = await memory.getMessages('agent-123');\n\n// Clear\nawait memory.clearMessages('agent-123');\n```\n\n## Agent with Memory\n\n```typescript\nexport class ConversationalAgent extends AIAgent<string, string> {\n  constructor(\n    private llmProvider: LLMProvider,\n    private memory: AgentMemory\n  ) {\n    super(EntityId.create<'AIAgent'>(), new Date(), new Date());\n  }\n\n  protected async execute(input: string): Promise<AgentResult<string>> {\n    // Load conversation history\n    const history = await this.memory.getMessages(this.id.toString());\n\n    // Call LLM with history\n    const response = await this.llmProvider.chat({\n      model: 'gpt-4o',\n      messages: [\n        ...history,\n        { role: 'user', content: input, timestamp: new Date() }\n      ]\n    });\n\n    // Save to memory\n    await this.memory.addMessage(this.id.toString(), {\n      role: 'user',\n      content: input,\n      timestamp: new Date()\n    });\n\n    await this.memory.addMessage(this.id.toString(), {\n      role: 'assistant',\n      content: response.content,\n      timestamp: new Date()\n    });\n\n    return AgentResult.success(response.content, response.usage);\n  }\n}\n```\n\n## Persistent Memory\n\n```typescript\nexport class PostgresAgentMemory implements AgentMemory {\n  constructor(private db: Database) {}\n\n  async addMessage(agentId: string, message: AgentMessage): Promise<void> {\n    await this.db('agent_messages').insert({\n      agent_id: agentId,\n      role: message.role,\n      content: message.content,\n      timestamp: message.timestamp\n    });\n  }\n\n  async getMessages(agentId: string, limit = 100): Promise<AgentMessage[]> {\n    const rows = await this.db('agent_messages')\n      .where({ agent_id: agentId })\n      .orderBy('timestamp', 'desc')\n      .limit(limit);\n\n    return rows.reverse();\n  }\n\n  async clearMessages(agentId: string): Promise<void> {\n    await this.db('agent_messages')\n      .where({ agent_id: agentId })\n      .delete();\n  }\n}\n```\n\n## Best Practices\n\n### 1. Limit Context Window\n\n```typescript\nconst messages = await memory.getMessages(agentId, 20); // Last 20 messages\n```\n\n### 2. Clear Old Conversations\n\n```typescript\n// Clear after session ends\nawait memory.clearMessages(agentId);\n```\n\n### 3. Handle Token Limits\n\n```typescript\nlet messages = await memory.getMessages(agentId);\n\n// Truncate if too many tokens\nwhile (this.countTokens(messages) > 4000) {\n  messages = messages.slice(1); // Remove oldest\n}\n```\n\n## Next Steps\n\n- **[Agent Orchestration](./agent-orchestration)** - Multi-agent workflows\n- **[Agent Testing](./agent-testing)** - Testing strategies\n",
      "metadata": {
        "type": "docs",
        "category": "ai-agents",
        "source": "docs/ai-agents/agent-memory.md",
        "title": "Agent Memory"
      }
    },
    {
      "id": "docs-ai-agents-agent-orchestration",
      "content": "\n# Agent Orchestration\n\nCoordinate multiple AI agents to solve complex problems.\n\n## Agent Orchestrator\n\n```typescript\nimport { StratixAgentOrchestrator } from '@stratix/runtime';\n\nconst orchestrator = new StratixAgentOrchestrator();\n\n// Register agents\norchestrator.registerAgent('support', supportAgent);\norchestrator.registerAgent('sales', salesAgent);\norchestrator.registerAgent('technical', technicalAgent);\n```\n\n## Routing Strategies\n\n### Intent-Based Routing\n\n```typescript\nconst result = await orchestrator.route(userInput, {\n  strategy: 'intent-based',\n  fallback: 'support'\n});\n```\n\n### Sequential Workflow\n\n```typescript\n// Agent 1 → Agent 2 → Agent 3\nconst step1 = await agent1.run(input);\nconst step2 = await agent2.run(step1.output);\nconst step3 = await agent3.run(step2.output);\n```\n\n### Parallel Execution\n\n```typescript\nconst [result1, result2, result3] = await Promise.all([\n  agent1.run(input),\n  agent2.run(input),\n  agent3.run(input)\n]);\n```\n\n## Multi-Agent Example\n\n```typescript\nexport class CustomerServiceOrchestrator {\n  constructor(\n    private supportAgent: SupportAgent,\n    private salesAgent: SalesAgent,\n    private technicalAgent: TechnicalAgent\n  ) {}\n\n  async handle(query: string): Promise<string> {\n    // Classify intent\n    const intent = await this.classifyIntent(query);\n\n    // Route to appropriate agent\n    switch (intent) {\n      case 'support':\n        return (await this.supportAgent.run(query)).output;\n      case 'sales':\n        return (await this.salesAgent.run(query)).output;\n      case 'technical':\n        return (await this.technicalAgent.run(query)).output;\n      default:\n        return (await this.supportAgent.run(query)).output;\n    }\n  }\n\n  private async classifyIntent(query: string): Promise<string> {\n    // Use classifier agent or simple rules\n    if (query.includes('buy') || query.includes('price')) {\n      return 'sales';\n    }\n    if (query.includes('error') || query.includes('bug')) {\n      return 'technical';\n    }\n    return 'support';\n  }\n}\n```\n\n## Best Practices\n\n### 1. Clear Agent Responsibilities\n\n```typescript\n// ✅ Good: Specialized agents\nsupportAgent  // Customer support\nsalesAgent    // Sales inquiries\ntechnicalAgent // Technical issues\n\n// ❌ Bad: Generic agent\ngeneralAgent  // Does everything\n```\n\n### 2. Handle Failures\n\n```typescript\nconst result = await agent1.run(input);\n\nif (result.isFailure) {\n  // Fallback to another agent\n  return await fallbackAgent.run(input);\n}\n```\n\n### 3. Track Costs\n\n```typescript\nlet totalCost = 0;\nfor (const result of results) {\n  totalCost += result.metadata.cost;\n}\nconsole.log('Total cost:', totalCost);\n```\n\n## Next Steps\n\n- **[Agent Testing](./agent-testing)** - Testing strategies\n- **[Creating Agents](./creating-agents)** - Build agents\n",
      "metadata": {
        "type": "docs",
        "category": "ai-agents",
        "source": "docs/ai-agents/agent-orchestration.md",
        "title": "Agent Orchestration"
      }
    },
    {
      "id": "docs-ai-agents-agent-testing",
      "content": "\n# Agent Testing\n\nTest AI agents effectively using mocks and assertions.\n\n## MockLLMProvider\n\n```typescript\nimport { MockLLMProvider } from '@stratix/testing';\n\nconst mockProvider = new MockLLMProvider({\n  responses: [\n    'First response',\n    'Second response',\n    'Third response'\n  ]\n});\n\nconst agent = new MyAgent(mockProvider);\n```\n\n## Basic Testing\n\n```typescript\nimport { MockLLMProvider } from '@stratix/testing';\n\ndescribe('CustomerSupportAgent', () => {\n  let agent: CustomerSupportAgent;\n  let mockProvider: MockLLMProvider;\n\n  beforeEach(() => {\n    mockProvider = new MockLLMProvider({\n      responses: [\n        'To reset your password, click \"Forgot Password\".'\n      ]\n    });\n    agent = new CustomerSupportAgent(mockProvider);\n  });\n\n  it('should provide password reset instructions', async () => {\n    const result = await agent.run({\n      question: 'How do I reset my password?',\n      customerTier: 'free'\n    });\n\n    expect(result.isSuccess).toBe(true);\n    expect(result.output.answer).toContain('Forgot Password');\n  });\n\n  it('should track token usage', async () => {\n    const result = await agent.run({\n      question: 'Test',\n      customerTier: 'premium'\n    });\n\n    expect(result.metadata.totalTokens).toBeGreaterThan(0);\n  });\n});\n```\n\n## Testing with AgentTester\n\n```typescript\nimport { AgentTester } from '@stratix/testing';\n\ndescribe('ProductRecommendationAgent', () => {\n  const tester = new AgentTester(agent);\n\n  it('should recommend products', async () => {\n    await tester\n      .withInput({ budget: 1000, preferences: 'laptop' })\n      .expectSuccess()\n      .expectOutput((output) => {\n        expect(output.length).toBeGreaterThan(0);\n        expect(output[0].price).toBeLessThanOrEqual(1000);\n      })\n      .run();\n  });\n});\n```\n\n## Testing Error Handling\n\n```typescript\nit('should handle LLM errors', async () => {\n  const errorProvider = new MockLLMProvider({\n    shouldFail: true,\n    error: new Error('API rate limit exceeded')\n  });\n\n  const agent = new MyAgent(errorProvider);\n  const result = await agent.run('test');\n\n  expect(result.isFailure).toBe(true);\n  expect(result.error.message).toContain('rate limit');\n});\n```\n\n## Testing Tool Calls\n\n```typescript\nit('should call weather tool', async () => {\n  const mockProvider = new MockLLMProvider({\n    responses: [\n      {\n        content: '',\n        toolCalls: [\n          {\n            id: 'call-1',\n            name: 'get_weather',\n            arguments: JSON.stringify({ location: 'NYC' })\n          }\n        ]\n      }\n    ]\n  });\n\n  const agent = new WeatherAgent(mockProvider);\n  const result = await agent.run('What is the weather in NYC?');\n\n  expect(result.isSuccess).toBe(true);\n});\n```\n\n## Integration Testing\n\n```typescript\ndescribe('Integration: CustomerServiceFlow', () => {\n  it('should handle end-to-end customer query', async () => {\n    // Use real provider with test API key\n    const provider = new OpenAIProvider({\n      apiKey: process.env.TEST_OPENAI_API_KEY!\n    });\n\n    const agent = new CustomerSupportAgent(provider);\n    const result = await agent.run({\n      question: 'How do I reset my password?',\n      customerTier: 'premium'\n    });\n\n    expect(result.isSuccess).toBe(true);\n    expect(result.output.answer).toBeTruthy();\n    expect(result.metadata.cost).toBeGreaterThan(0);\n  });\n});\n```\n\n## Best Practices\n\n### 1. Use Mocks for Unit Tests\n\n```typescript\nconst mockProvider = new MockLLMProvider({\n  responses: ['Expected response']\n});\n```\n\n### 2. Test Error Cases\n\n```typescript\nit('should handle invalid input', async () => {\n  const result = await agent.run(null);\n  expect(result.isFailure).toBe(true);\n});\n```\n\n### 3. Verify Metadata\n\n```typescript\nexpect(result.metadata.totalTokens).toBeGreaterThan(0);\nexpect(result.metadata.cost).toBeGreaterThan(0);\n```\n\n### 4. Test with Real Provider (Sparingly)\n\n```typescript\n// Only for critical integration tests\nconst provider = new OpenAIProvider({\n  apiKey: process.env.TEST_API_KEY\n});\n```\n\n## Next Steps\n\n- **[AI Agents Overview](./ai-agents-overview)** - AI agents guide\n- **[Creating Agents](./creating-agents)** - Agent creation\n- **[LLM Providers](./llm-providers)** - Provider configuration\n",
      "metadata": {
        "type": "docs",
        "category": "ai-agents",
        "source": "docs/ai-agents/agent-testing.md",
        "title": "Agent Testing"
      }
    },
    {
      "id": "docs-ai-agents-agent-tools",
      "content": "\n# Agent Tools\n\nEnable AI agents to call functions and interact with external systems using tools.\n\n## What are Agent Tools?\n\nTools allow agents to:\n- Call functions in your codebase\n- Query databases\n- Make API calls\n- Perform calculations\n- Access external services\n\n## Basic Tool Definition\n\n```typescript\nconst weatherTool = {\n  name: 'get_weather',\n  description: 'Get current weather for a location',\n  parameters: {\n    type: 'object',\n    properties: {\n      location: {\n        type: 'string',\n        description: 'City name'\n      },\n      unit: {\n        type: 'string',\n        enum: ['celsius', 'fahrenheit'],\n        description: 'Temperature unit'\n      }\n    },\n    required: ['location']\n  }\n};\n```\n\n## Agent with Tools\n\n```typescript\nexport class WeatherAgent extends AIAgent<string, string> {\n  readonly name = 'Weather Agent';\n  readonly capabilities = [\n    AgentCapabilities.TEXT_GENERATION,\n    AgentCapabilities.FUNCTION_CALLING\n  ];\n\n  protected async execute(input: string): Promise<AgentResult<string>> {\n    const response = await this.llmProvider.chat({\n      model: 'gpt-4o',\n      messages: [\n        { role: 'user', content: input, timestamp: new Date() }\n      ],\n      tools: [\n        {\n          name: 'get_weather',\n          description: 'Get current weather',\n          parameters: {\n            type: 'object',\n            properties: {\n              location: { type: 'string' }\n            },\n            required: ['location']\n          }\n        }\n      ]\n    });\n\n    // Handle tool calls\n    if (response.toolCalls) {\n      const results = await this.executeTools(response.toolCalls);\n      \n      // Send results back to LLM\n      const finalResponse = await this.llmProvider.chat({\n        model: 'gpt-4o',\n        messages: [\n          { role: 'user', content: input, timestamp: new Date() },\n          { role: 'assistant', content: response.content, timestamp: new Date(), toolCalls: response.toolCalls },\n          ...results.map(r => ({\n            role: 'tool' as const,\n            content: JSON.stringify(r.result),\n            toolCallId: r.id,\n            timestamp: new Date()\n          }))\n        ]\n      });\n\n      return AgentResult.success(finalResponse.content, finalResponse.usage);\n    }\n\n    return AgentResult.success(response.content, response.usage);\n  }\n\n  private async executeTools(toolCalls: ToolCall[]): Promise<ToolResult[]> {\n    const results: ToolResult[] = [];\n\n    for (const call of toolCalls) {\n      if (call.name === 'get_weather') {\n        const args = JSON.parse(call.arguments);\n        const weather = await this.getWeather(args.location);\n        results.push({\n          id: call.id,\n          result: weather\n        });\n      }\n    }\n\n    return results;\n  }\n\n  private async getWeather(location: string): Promise<any> {\n    // Call weather API\n    return { temperature: 72, condition: 'sunny' };\n  }\n}\n```\n\n## Multiple Tools\n\n```typescript\nconst tools = [\n  {\n    name: 'search_products',\n    description: 'Search for products',\n    parameters: {\n      type: 'object',\n      properties: {\n        query: { type: 'string' },\n        category: { type: 'string' }\n      }\n    }\n  },\n  {\n    name: 'get_product_details',\n    description: 'Get product details',\n    parameters: {\n      type: 'object',\n      properties: {\n        productId: { type: 'string' }\n      }\n    }\n  },\n  {\n    name: 'check_inventory',\n    description: 'Check product inventory',\n    parameters: {\n      type: 'object',\n      properties: {\n        productId: { type: 'string' }\n      }\n    }\n  }\n];\n```\n\n## Best Practices\n\n### 1. Clear Tool Descriptions\n\n```typescript\n// ✅ Good\ndescription: 'Get current weather for a specific location'\n\n// ❌ Bad\ndescription: 'Weather'\n```\n\n### 2. Validate Tool Arguments\n\n```typescript\nprivate async executeTools(toolCalls: ToolCall[]): Promise<ToolResult[]> {\n  for (const call of toolCalls) {\n    const args = JSON.parse(call.arguments);\n    \n    // Validate\n    if (!args.location) {\n      throw new Error('Location is required');\n    }\n    \n    // Execute\n    const result = await this.getWeather(args.location);\n  }\n}\n```\n\n### 3. Handle Errors\n\n```typescript\ntry {\n  const result = await this.executeTool(call);\n  results.push({ id: call.id, result });\n} catch (error) {\n  results.push({\n    id: call.id,\n    error: error.message\n  });\n}\n```\n\n## Next Steps\n\n- **[Agent Memory](./agent-memory)** - Conversation history\n- **[Agent Orchestration](./agent-orchestration)** - Multi-agent workflows\n",
      "metadata": {
        "type": "docs",
        "category": "ai-agents",
        "source": "docs/ai-agents/agent-tools.md",
        "title": "Agent Tools"
      }
    },
    {
      "id": "docs-ai-agents-ai-agents-overview",
      "content": "\n# AI Agents Overview\n\nStratix treats **AI agents as first-class domain entities**, not as afterthoughts or external services. This AI-first approach enables you to build production-ready AI applications with the same rigor as traditional business logic.\n\n## Why AI-First?\n\nTraditional frameworks treat AI as an external integration. Stratix is different:\n\n```mermaid\ngraph TB\n    subgraph \"Traditional Approach\"\n        App1[Application]\n        AI1[AI Service<br/>External]\n        App1 -.->|HTTP calls| AI1\n    end\n    \n    subgraph \"Stratix AI-First\"\n        Domain[Domain Layer]\n        Agent[AI Agent<br/>Domain Entity]\n        LLM[LLM Provider<br/>Infrastructure]\n        \n        Domain --> Agent\n        Agent --> LLM\n    end\n    \n    style Agent fill:#4CAF50\n    style AI1 fill:#FF9800\n```\n\n### Benefits\n\n✅ **Type Safety** - AI agents are strongly typed TypeScript classes  \n✅ **Testability** - Mock LLM providers for testing  \n✅ **Versioning** - Track agent versions like any other code  \n✅ **Observability** - Built-in execution tracing and metrics  \n✅ **Production Patterns** - Memory management, error handling, cost tracking  \n\n## AIAgent Base Class\n\nAll AI agents extend the `AIAgent` base class:\n\n```typescript\nimport { AIAgent, AgentResult, AgentCapabilities } from '@stratix/core';\n\nclass CustomerSupportAgent extends AIAgent<string, string> {\n  readonly name = 'Customer Support Agent';\n  readonly description = 'Handles customer inquiries and support tickets';\n  readonly version = AgentVersionFactory.create('1.0.0');\n  readonly capabilities = [AgentCapabilities.TEXT_GENERATION];\n  \n  readonly model = {\n    provider: 'openai',\n    model: 'gpt-4o',\n    temperature: 0.7,\n    maxTokens: 1000\n  };\n\n  constructor(private llmProvider: LLMProvider) {\n    super(EntityId.create<'AIAgent'>(), new Date(), new Date());\n  }\n\n  protected async execute(input: string): Promise<AgentResult<string>> {\n    const response = await this.llmProvider.chat({\n      model: this.model.model,\n      messages: [\n        { role: 'system', content: 'You are a helpful customer support agent.' },\n        { role: 'user', content: input, timestamp: new Date() }\n      ],\n      temperature: this.model.temperature,\n      maxTokens: this.model.maxTokens\n    });\n\n    return AgentResult.success(response.content, {\n      model: response.model,\n      totalTokens: response.usage.totalTokens,\n      cost: this.llmProvider.calculateCost(this.model.model, response.usage)\n    });\n  }\n}\n```\n\n## Agent Capabilities\n\nStratix defines standard agent capabilities:\n\n```typescript\nimport { AgentCapabilities } from '@stratix/core';\n\nenum AgentCapabilities {\n  TEXT_GENERATION = 'TEXT_GENERATION',\n  TEXT_ANALYSIS = 'TEXT_ANALYSIS',\n  CODE_GENERATION = 'CODE_GENERATION',\n  FUNCTION_CALLING = 'FUNCTION_CALLING',\n  VISION = 'VISION',\n  AUDIO = 'AUDIO',\n  EMBEDDINGS = 'EMBEDDINGS'\n}\n```\n\n## LLM Providers\n\nStratix supports multiple LLM providers out of the box:\n\n### OpenAI\n\n```typescript\nimport { OpenAIProvider } from '@stratix/ai-openai';\n\nconst provider = new OpenAIProvider({\n  apiKey: process.env.OPENAI_API_KEY!\n});\n\nconst agent = new CustomerSupportAgent(provider);\n```\n\n### Anthropic (Claude)\n\n```typescript\nimport { AnthropicProvider } from '@stratix/ai-anthropic';\n\nconst provider = new AnthropicProvider({\n  apiKey: process.env.ANTHROPIC_API_KEY!\n});\n\nconst agent = new CustomerSupportAgent(provider);\n```\n\n### Custom Providers\n\n```typescript\nimport { LLMProvider } from '@stratix/core';\n\nclass CustomLLMProvider implements LLMProvider {\n  async chat(request: ChatRequest): Promise<ChatResponse> {\n    // Your implementation\n  }\n\n  async streamChat(request: ChatRequest): AsyncGenerator<ChatChunk> {\n    // Your implementation\n  }\n\n  calculateCost(model: string, usage: TokenUsage): number {\n    // Your implementation\n  }\n}\n```\n\n## Agent Execution\n\n### Basic Execution\n\n```typescript\nconst agent = new CustomerSupportAgent(llmProvider);\n\nconst result = await agent.run('How do I reset my password?');\n\nif (result.isSuccess) {\n  console.log('Response:', result.output);\n  console.log('Tokens used:', result.metadata.totalTokens);\n  console.log('Cost:', result.metadata.cost);\n} else {\n  console.error('Error:', result.error);\n}\n```\n\n### With Context\n\n```typescript\nconst context = new AgentContext({\n  userId: 'user-123',\n  sessionId: 'session-456',\n  metadata: {\n    customerTier: 'premium',\n    language: 'en'\n  }\n});\n\nconst result = await agent.run(input, context);\n```\n\n## Production Features\n\n### 1. Execution Tracing\n\nTrack every agent execution:\n\n```typescript\nconst result = await agent.run(input);\n\nconst trace = result.trace;\nconsole.log('Started:', trace.startedAt);\nconsole.log('Completed:', trace.completedAt);\nconsole.log('Duration:', trace.duration);\nconsole.log('Steps:', trace.steps);\n```\n\n### 2. Cost Tracking\n\nMonitor LLM costs:\n\n```typescript\nconst result = await agent.run(input);\n\nconsole.log('Tokens:', result.metadata.totalTokens);\nconsole.log('Cost:', result.metadata.cost);\n\n// Aggregate costs\nlet totalCost = 0;\nfor (const execution of executions) {\n  totalCost += execution.metadata.cost;\n}\n```\n\n### 3. Error Handling\n\nRobust error handling with Result pattern:\n\n```typescript\nconst result = await agent.run(input);\n\nif (result.isSuccess) {\n  // Handle success\n  console.log(result.output);\n} else {\n  // Handle error\n  if (result.error instanceof AgentBudgetExceededError) {\n    console.error('Budget exceeded');\n  } else if (result.error instanceof AgentTimeoutError) {\n    console.error('Timeout');\n  } else {\n    console.error('Unknown error:', result.error);\n  }\n}\n```\n\n### 4. Memory Management\n\nAgents can maintain conversation history:\n\n```typescript\nimport { InMemoryAgentMemory } from '@stratix/runtime';\n\nconst memory = new InMemoryAgentMemory();\n\nclass ConversationalAgent extends AIAgent<string, string> {\n  async execute(input: string): Promise<AgentResult<string>> {\n    // Load conversation history\n    const history = await memory.getMessages(this.id);\n\n    const response = await this.llmProvider.chat({\n      model: this.model.model,\n      messages: [\n        ...history,\n        { role: 'user', content: input, timestamp: new Date() }\n      ]\n    });\n\n    // Save to memory\n    await memory.addMessage(this.id, {\n      role: 'user',\n      content: input,\n      timestamp: new Date()\n    });\n    await memory.addMessage(this.id, {\n      role: 'assistant',\n      content: response.content,\n      timestamp: new Date()\n    });\n\n    return AgentResult.success(response.content, response.usage);\n  }\n}\n```\n\n## Agent Orchestration\n\nCoordinate multiple agents:\n\n```typescript\nimport { StratixAgentOrchestrator } from '@stratix/runtime';\n\nconst orchestrator = new StratixAgentOrchestrator();\n\n// Register agents\norchestrator.registerAgent('support', supportAgent);\norchestrator.registerAgent('sales', salesAgent);\norchestrator.registerAgent('technical', technicalAgent);\n\n// Route to appropriate agent\nconst result = await orchestrator.route(userInput, {\n  strategy: 'intent-based',\n  fallback: 'support'\n});\n```\n\n## Integration with Domain\n\nAgents are domain entities and can be used in CQRS:\n\n```typescript\n// Command\nexport class AnalyzeCustomerFeedbackCommand implements Command {\n  constructor(\n    public readonly feedbackId: string,\n    public readonly text: string\n  ) {}\n}\n\n// Handler\nexport class AnalyzeCustomerFeedbackHandler \n  implements CommandHandler<AnalyzeCustomerFeedbackCommand, FeedbackAnalysis> {\n  \n  constructor(\n    private analysisAgent: FeedbackAnalysisAgent,\n    private feedbackRepository: IFeedbackRepository\n  ) {}\n\n  async handle(command: AnalyzeCustomerFeedbackCommand): Promise<Result<FeedbackAnalysis>> {\n    // Run AI agent\n    const result = await this.analysisAgent.run(command.text);\n\n    if (result.isFailure) {\n      return Failure.create(result.error);\n    }\n\n    // Create domain entity\n    const analysis = new FeedbackAnalysis(\n      EntityId.create<'FeedbackAnalysis'>(),\n      command.feedbackId,\n      result.output,\n      new Date(),\n      new Date()\n    );\n\n    // Persist\n    await this.feedbackRepository.saveAnalysis(analysis);\n\n    return Success.create(analysis);\n  }\n}\n```\n\n## HTTP Integration\n\nExpose agents via HTTP:\n\n```typescript\nimport { FastifyHTTPPlugin } from '@stratix/http-fastify';\n\nhttpPlugin.post('/api/agents/support', async (request) => {\n  const { message } = request.body;\n\n  const result = await supportAgent.run(message);\n\n  if (result.isFailure) {\n    throw HttpErrorImpl.internalServerError(result.error.message);\n  }\n\n  return {\n    body: {\n      response: result.output,\n      metadata: {\n        tokens: result.metadata.totalTokens,\n        cost: result.metadata.cost,\n        duration: result.trace.duration\n      }\n    }\n  };\n});\n```\n\n## Testing Agents\n\nUse MockLLMProvider for testing:\n\n```typescript\nimport { MockLLMProvider } from '@stratix/testing';\n\ndescribe('CustomerSupportAgent', () => {\n  it('should respond to password reset question', async () => {\n    const mockProvider = new MockLLMProvider({\n      responses: [\n        'To reset your password, click \"Forgot Password\" on the login page.'\n      ]\n    });\n\n    const agent = new CustomerSupportAgent(mockProvider);\n    const result = await agent.run('How do I reset my password?');\n\n    expect(result.isSuccess).toBe(true);\n    expect(result.output).toContain('Forgot Password');\n  });\n});\n```\n\n## Real-World Example\n\n```typescript\n// Domain entity\nclass ProductRecommendationAgent extends AIAgent<ProductQuery, ProductRecommendation[]> {\n  readonly name = 'Product Recommendation Agent';\n  readonly version = AgentVersionFactory.create('1.0.0');\n  readonly capabilities = [AgentCapabilities.TEXT_GENERATION];\n\n  constructor(\n    private llmProvider: LLMProvider,\n    private productRepository: IProductRepository\n  ) {\n    super(EntityId.create<'AIAgent'>(), new Date(), new Date());\n  }\n\n  protected async execute(query: ProductQuery): Promise<AgentResult<ProductRecommendation[]>> {\n    // Get available products\n    const products = await this.productRepository.findAll();\n\n    // Build prompt\n    const prompt = `\n      User preferences: ${query.preferences}\n      Budget: ${query.budget}\n      \n      Available products:\n      ${products.map(p => `- ${p.name}: $${p.price}`).join('\\n')}\n      \n      Recommend the top 3 products and explain why.\n    `;\n\n    // Call LLM\n    const response = await this.llmProvider.chat({\n      model: 'gpt-4o',\n      messages: [\n        { role: 'system', content: 'You are a product recommendation expert.' },\n        { role: 'user', content: prompt, timestamp: new Date() }\n      ]\n    });\n\n    // Parse recommendations\n    const recommendations = this.parseRecommendations(response.content);\n\n    return AgentResult.success(recommendations, response.usage);\n  }\n\n  private parseRecommendations(text: string): ProductRecommendation[] {\n    // Parse LLM response into structured data\n    // ...\n  }\n}\n```\n\n## Best Practices\n\n### 1. Version Your Agents\n\n```typescript\nreadonly version = AgentVersionFactory.create('1.2.0');\n```\n\n### 2. Define Clear Capabilities\n\n```typescript\nreadonly capabilities = [\n  AgentCapabilities.TEXT_GENERATION,\n  AgentCapabilities.FUNCTION_CALLING\n];\n```\n\n### 3. Use Result Pattern\n\n```typescript\nconst result = await agent.run(input);\nif (result.isSuccess) {\n  // Handle success\n} else {\n  // Handle error\n}\n```\n\n### 4. Track Costs\n\n```typescript\nconsole.log('Cost:', result.metadata.cost);\n```\n\n### 5. Test with Mocks\n\n```typescript\nconst mockProvider = new MockLLMProvider({ responses: [...] });\n```\n\n## Next Steps\n\n- **[Creating Agents](./creating-agents)** - Build your first agent\n- **[LLM Providers](./llm-providers)** - OpenAI, Anthropic, custom providers\n- **[Agent Tools](./agent-tools)** - Function calling and tools\n- **[Agent Memory](./agent-memory)** - Conversation history\n- **[Agent Orchestration](./agent-orchestration)** - Multi-agent workflows\n- **[Agent Testing](./agent-testing)** - Testing strategies\n",
      "metadata": {
        "type": "docs",
        "category": "ai-agents",
        "source": "docs/ai-agents/ai-agents-overview.md",
        "title": "AI Agents Overview"
      }
    },
    {
      "id": "docs-ai-agents-creating-agents",
      "content": "\n# Creating Agents\n\nLearn how to create production-ready AI agents using Stratix's `AIAgent` base class.\n\n## Basic Agent Structure\n\n```typescript\nimport { AIAgent, AgentResult, AgentCapabilities, AgentVersionFactory, EntityId } from '@stratix/core';\nimport type { LLMProvider } from '@stratix/core';\n\nexport class MyAgent extends AIAgent<InputType, OutputType> {\n  // Required metadata\n  readonly name = 'My Agent';\n  readonly description = 'What this agent does';\n  readonly version = AgentVersionFactory.create('1.0.0');\n  readonly capabilities = [AgentCapabilities.TEXT_GENERATION];\n  \n  // Model configuration\n  readonly model = {\n    provider: 'openai',\n    model: 'gpt-4o',\n    temperature: 0.7,\n    maxTokens: 1000\n  };\n\n  constructor(private llmProvider: LLMProvider) {\n    super(EntityId.create<'AIAgent'>(), new Date(), new Date());\n  }\n\n  // Implement execution logic\n  protected async execute(input: InputType): Promise<AgentResult<OutputType>> {\n    // Your agent logic here\n  }\n}\n```\n\n## Complete Example: Customer Support Agent\n\n```typescript\nimport { AIAgent, AgentResult, AgentCapabilities, AgentVersionFactory } from '@stratix/core';\n\ninterface SupportQuery {\n  question: string;\n  customerTier: 'free' | 'premium' | 'enterprise';\n  previousInteractions?: number;\n}\n\ninterface SupportResponse {\n  answer: string;\n  confidence: number;\n  suggestedActions: string[];\n}\n\nexport class CustomerSupportAgent extends AIAgent<SupportQuery, SupportResponse> {\n  readonly name = 'Customer Support Agent';\n  readonly description = 'Provides customer support responses with contextual awareness';\n  readonly version = AgentVersionFactory.create('1.0.0');\n  readonly capabilities = [AgentCapabilities.TEXT_GENERATION];\n  \n  readonly model = {\n    provider: 'openai',\n    model: 'gpt-4o',\n    temperature: 0.7,\n    maxTokens: 500\n  };\n\n  constructor(private llmProvider: LLMProvider) {\n    super(EntityId.create<'AIAgent'>(), new Date(), new Date());\n  }\n\n  protected async execute(input: SupportQuery): Promise<AgentResult<SupportResponse>> {\n    // Build context-aware prompt\n    const systemPrompt = this.buildSystemPrompt(input.customerTier);\n    const userPrompt = this.buildUserPrompt(input);\n\n    // Call LLM\n    const response = await this.llmProvider.chat({\n      model: this.model.model,\n      messages: [\n        { role: 'system', content: systemPrompt, timestamp: new Date() },\n        { role: 'user', content: userPrompt, timestamp: new Date() }\n      ],\n      temperature: this.model.temperature,\n      maxTokens: this.model.maxTokens\n    });\n\n    // Parse and structure response\n    const structuredResponse = this.parseResponse(response.content);\n\n    return AgentResult.success(structuredResponse, {\n      model: response.model,\n      totalTokens: response.usage.totalTokens,\n      cost: this.llmProvider.calculateCost(this.model.model, response.usage)\n    });\n  }\n\n  private buildSystemPrompt(tier: string): string {\n    const baseTone = 'You are a helpful customer support agent.';\n    \n    switch (tier) {\n      case 'enterprise':\n        return `${baseTone} Provide detailed, technical responses with priority support.`;\n      case 'premium':\n        return `${baseTone} Provide thorough responses with helpful suggestions.`;\n      default:\n        return `${baseTone} Provide clear, concise responses.`;\n    }\n  }\n\n  private buildUserPrompt(input: SupportQuery): string {\n    let prompt = `Question: ${input.question}`;\n    \n    if (input.previousInteractions) {\n      prompt += `\\n\\nNote: Customer has ${input.previousInteractions} previous interactions.`;\n    }\n    \n    return prompt;\n  }\n\n  private parseResponse(content: string): SupportResponse {\n    // Parse LLM response into structured format\n    return {\n      answer: content,\n      confidence: 0.85,\n      suggestedActions: ['Check documentation', 'Contact support']\n    };\n  }\n}\n```\n\n## Agent Metadata\n\n### Name and Description\n\n```typescript\nreadonly name = 'Product Recommendation Agent';\nreadonly description = 'Analyzes user preferences and recommends products';\n```\n\n### Versioning\n\n```typescript\nimport { AgentVersionFactory } from '@stratix/core';\n\nreadonly version = AgentVersionFactory.create('1.2.0');\n```\n\nVersion changes when:\n- **Major** (1.x.x → 2.x.x): Breaking changes in input/output\n- **Minor** (x.1.x → x.2.x): New features, backwards compatible\n- **Patch** (x.x.1 → x.x.2): Bug fixes\n\n### Capabilities\n\n```typescript\nreadonly capabilities = [\n  AgentCapabilities.TEXT_GENERATION,\n  AgentCapabilities.FUNCTION_CALLING\n];\n```\n\n## Model Configuration\n\n```typescript\nreadonly model = {\n  provider: 'openai',      // or 'anthropic', 'custom'\n  model: 'gpt-4o',         // Specific model\n  temperature: 0.7,        // 0.0 = deterministic, 1.0 = creative\n  maxTokens: 1000,         // Maximum response length\n  topP: 0.9,              // Optional: nucleus sampling\n  frequencyPenalty: 0,    // Optional: reduce repetition\n  presencePenalty: 0      // Optional: encourage new topics\n};\n```\n\n## Error Handling\n\n```typescript\nprotected async execute(input: InputType): Promise<AgentResult<OutputType>> {\n  try {\n    const response = await this.llmProvider.chat({...});\n    return AgentResult.success(output, metadata);\n  } catch (error) {\n    if (error instanceof LLMProviderError) {\n      return AgentResult.failure(\n        new AgentExecutionError('LLM provider failed', error)\n      );\n    }\n    return AgentResult.failure(error);\n  }\n}\n```\n\n## Streaming Responses\n\n```typescript\nexport class StreamingAgent extends AIAgent<string, string> {\n  async *stream(input: string): AsyncGenerator<string> {\n    const stream = this.llmProvider.streamChat({\n      model: this.model.model,\n      messages: [\n        { role: 'user', content: input, timestamp: new Date() }\n      ]\n    });\n\n    for await (const chunk of stream) {\n      yield chunk.content;\n    }\n  }\n}\n\n// Usage\nfor await (const chunk of agent.stream('Tell me a story')) {\n  process.stdout.write(chunk);\n}\n```\n\n## Testing Agents\n\n```typescript\nimport { MockLLMProvider } from '@stratix/testing';\n\ndescribe('CustomerSupportAgent', () => {\n  let agent: CustomerSupportAgent;\n  let mockProvider: MockLLMProvider;\n\n  beforeEach(() => {\n    mockProvider = new MockLLMProvider({\n      responses: [\n        'To reset your password, click \"Forgot Password\" on the login page.'\n      ]\n    });\n    agent = new CustomerSupportAgent(mockProvider);\n  });\n\n  it('should provide password reset instructions', async () => {\n    const result = await agent.run({\n      question: 'How do I reset my password?',\n      customerTier: 'free'\n    });\n\n    expect(result.isSuccess).toBe(true);\n    expect(result.output.answer).toContain('Forgot Password');\n  });\n\n  it('should track token usage', async () => {\n    const result = await agent.run({\n      question: 'Test question',\n      customerTier: 'premium'\n    });\n\n    expect(result.metadata.totalTokens).toBeGreaterThan(0);\n    expect(result.metadata.cost).toBeGreaterThan(0);\n  });\n});\n```\n\n## Best Practices\n\n### 1. Use Descriptive Names\n\n```typescript\n// ✅ Good\nreadonly name = 'Customer Support Agent';\n\n// ❌ Bad\nreadonly name = 'Agent1';\n```\n\n### 2. Version Your Agents\n\n```typescript\nreadonly version = AgentVersionFactory.create('1.0.0');\n```\n\n### 3. Handle Errors Gracefully\n\n```typescript\ntry {\n  const response = await this.llmProvider.chat({...});\n  return AgentResult.success(output, metadata);\n} catch (error) {\n  return AgentResult.failure(error);\n}\n```\n\n### 4. Structure Your Output\n\n```typescript\n// ✅ Good: Structured output\ninterface ProductRecommendation {\n  productId: string;\n  reason: string;\n  confidence: number;\n}\n\n// ❌ Bad: Unstructured string\ntype Output = string;\n```\n\n### 5. Test with Mocks\n\n```typescript\nconst mockProvider = new MockLLMProvider({\n  responses: ['Expected response']\n});\n```\n\n## Next Steps\n\n- **[LLM Providers](./llm-providers)** - OpenAI, Anthropic, custom providers\n- **[Agent Tools](./agent-tools)** - Function calling\n- **[Agent Memory](./agent-memory)** - Conversation history\n- **[Agent Testing](./agent-testing)** - Testing strategies\n",
      "metadata": {
        "type": "docs",
        "category": "ai-agents",
        "source": "docs/ai-agents/creating-agents.md",
        "title": "Creating Agents"
      }
    },
    {
      "id": "docs-ai-agents-llm-providers",
      "content": "\n# LLM Providers\n\nStratix supports multiple LLM providers through a unified `LLMProvider` interface.\n\n## Supported Providers\n\n- **OpenAI** - GPT-4, GPT-4 Turbo, GPT-3.5\n- **Anthropic** - Claude 3 (Opus, Sonnet, Haiku)\n- **Custom** - Build your own provider\n\n## OpenAI Provider\n\n### Installation\n\n```bash\nnpm install @stratix/ai-openai\n```\n\n### Setup\n\n```typescript\nimport { OpenAIProvider } from '@stratix/ai-openai';\n\nconst provider = new OpenAIProvider({\n  apiKey: process.env.OPENAI_API_KEY!,\n  organization: 'org-123', // Optional\n  baseURL: 'https://api.openai.com/v1' // Optional\n});\n```\n\n### Supported Models\n\n```typescript\n// GPT-4 models\n'gpt-4o'              // Latest, fastest GPT-4\n'gpt-4o-mini'         // Smaller, faster\n'gpt-4-turbo'         // High performance\n'gpt-4'               // Base model\n\n// GPT-3.5 models\n'gpt-3.5-turbo'       // Fast and cost-effective\n'gpt-3.5-turbo-16k'   // Extended context\n\n// Embedding models\n'text-embedding-3-small'\n'text-embedding-3-large'\n```\n\n### Usage\n\n```typescript\nconst response = await provider.chat({\n  model: 'gpt-4o',\n  messages: [\n    { role: 'system', content: 'You are a helpful assistant.', timestamp: new Date() },\n    { role: 'user', content: 'Hello!', timestamp: new Date() }\n  ],\n  temperature: 0.7,\n  maxTokens: 1000\n});\n\nconsole.log(response.content);\nconsole.log('Tokens:', response.usage.totalTokens);\nconsole.log('Cost:', provider.calculateCost('gpt-4o', response.usage));\n```\n\n### Function Calling\n\n```typescript\nconst response = await provider.chat({\n  model: 'gpt-4o',\n  messages: [\n    { role: 'user', content: 'What is the weather in NYC?', timestamp: new Date() }\n  ],\n  tools: [\n    {\n      name: 'get_weather',\n      description: 'Get current weather',\n      parameters: {\n        type: 'object',\n        properties: {\n          location: { type: 'string' }\n        },\n        required: ['location']\n      }\n    }\n  ]\n});\n\nif (response.toolCalls) {\n  console.log('Tool:', response.toolCalls[0].name);\n  console.log('Args:', response.toolCalls[0].arguments);\n}\n```\n\n## Anthropic Provider\n\n### Installation\n\n```bash\nnpm install @stratix/ai-anthropic\n```\n\n### Setup\n\n```typescript\nimport { AnthropicProvider } from '@stratix/ai-anthropic';\n\nconst provider = new AnthropicProvider({\n  apiKey: process.env.ANTHROPIC_API_KEY!\n});\n```\n\n### Supported Models\n\n```typescript\n'claude-3-opus-20240229'    // Most capable\n'claude-3-sonnet-20240229'  // Balanced\n'claude-3-haiku-20240307'   // Fastest\n```\n\n### Usage\n\n```typescript\nconst response = await provider.chat({\n  model: 'claude-3-sonnet-20240229',\n  messages: [\n    { role: 'user', content: 'Explain quantum computing', timestamp: new Date() }\n  ],\n  maxTokens: 1000\n});\n```\n\n## Custom Provider\n\n### Implementation\n\n```typescript\nimport { LLMProvider, ChatRequest, ChatResponse, ChatChunk, TokenUsage } from '@stratix/core';\n\nexport class CustomLLMProvider implements LLMProvider {\n  constructor(private config: CustomConfig) {}\n\n  async chat(request: ChatRequest): Promise<ChatResponse> {\n    // Call your LLM API\n    const response = await fetch('https://your-llm-api.com/chat', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${this.config.apiKey}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        model: request.model,\n        messages: request.messages,\n        temperature: request.temperature,\n        max_tokens: request.maxTokens\n      })\n    });\n\n    const data = await response.json();\n\n    return {\n      content: data.choices[0].message.content,\n      model: request.model,\n      usage: {\n        promptTokens: data.usage.prompt_tokens,\n        completionTokens: data.usage.completion_tokens,\n        totalTokens: data.usage.total_tokens\n      },\n      finishReason: data.choices[0].finish_reason\n    };\n  }\n\n  async *streamChat(request: ChatRequest): AsyncGenerator<ChatChunk> {\n    // Implement streaming\n    const response = await fetch('https://your-llm-api.com/chat/stream', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${this.config.apiKey}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({...request, stream: true})\n    });\n\n    const reader = response.body!.getReader();\n    const decoder = new TextDecoder();\n\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      const chunk = decoder.decode(value);\n      yield { content: chunk, delta: chunk };\n    }\n  }\n\n  calculateCost(model: string, usage: TokenUsage): number {\n    // Your pricing logic\n    const inputCost = 0.01 / 1000;  // per 1K tokens\n    const outputCost = 0.03 / 1000; // per 1K tokens\n\n    return (\n      (usage.promptTokens * inputCost) +\n      (usage.completionTokens * outputCost)\n    );\n  }\n\n  async embeddings(request: EmbeddingsRequest): Promise<EmbeddingsResponse> {\n    // Implement embeddings if supported\n    throw new Error('Not implemented');\n  }\n}\n```\n\n## Provider Comparison\n\n| Feature | OpenAI | Anthropic | Custom |\n|---------|--------|-----------|--------|\n| **Chat** | ✅ | ✅ | ✅ |\n| **Streaming** | ✅ | ✅ | ✅ |\n| **Function Calling** | ✅ | ✅ | Optional |\n| **Embeddings** | ✅ | ❌ | Optional |\n| **Vision** | ✅ | ✅ | Optional |\n| **Cost Tracking** | ✅ | ✅ | ✅ |\n\n## Best Practices\n\n### 1. Use Environment Variables\n\n```typescript\nconst provider = new OpenAIProvider({\n  apiKey: process.env.OPENAI_API_KEY!\n});\n```\n\n### 2. Handle Rate Limits\n\n```typescript\ntry {\n  const response = await provider.chat(request);\n} catch (error) {\n  if (error instanceof RateLimitError) {\n    // Retry with exponential backoff\n    await sleep(1000);\n    return await provider.chat(request);\n  }\n  throw error;\n}\n```\n\n### 3. Track Costs\n\n```typescript\nconst cost = provider.calculateCost(model, response.usage);\nconsole.log(`Cost: $${cost.toFixed(4)}`);\n```\n\n### 4. Use Appropriate Models\n\n```typescript\n// For simple tasks\nmodel: 'gpt-3.5-turbo'\n\n// For complex reasoning\nmodel: 'gpt-4o'\n\n// For speed\nmodel: 'claude-3-haiku-20240307'\n```\n\n## Next Steps\n\n- **[Agent Tools](./agent-tools)** - Function calling\n- **[Agent Memory](./agent-memory)** - Conversation history\n- **[Creating Agents](./creating-agents)** - Build agents\n",
      "metadata": {
        "type": "docs",
        "category": "ai-agents",
        "source": "docs/ai-agents/llm-providers.md",
        "title": "LLM Providers"
      }
    },
    {
      "id": "docs-cli-add-command",
      "content": "\n# add Command\n\nAdd official and third-party extensions to your Stratix project.\n\n## Usage\n\n```bash\nstratix add <extension> [options]\n```\n\n## Interactive Mode\n\n```bash\nstratix add\n```\n\nBrowse and select from available extensions.\n\n## Non-Interactive Mode\n\n```bash\nstratix add @stratix/http-fastify\nstratix add @stratix/postgres --skip-install\n```\n\n## Official Extensions\n\n### HTTP Servers\n\n```bash\n# Fastify (Recommended)\nstratix add @stratix/http-fastify\n\n# Express\nstratix add @stratix/http-express\n```\n\n### Databases\n\n```bash\n# PostgreSQL\nstratix add @stratix/postgres\n\n# MongoDB\nstratix add @stratix/mongodb\n\n# Redis\nstratix add @stratix/redis\n```\n\n### AI Providers\n\n```bash\n# OpenAI\nstratix add @stratix/ai-openai\n\n# Anthropic (Claude)\nstratix add @stratix/ai-anthropic\n```\n\n### Message Queues\n\n```bash\n# RabbitMQ\nstratix add @stratix/rabbitmq\n\n# Kafka\nstratix add @stratix/kafka\n```\n\n### Utilities\n\n```bash\n# Logging\nstratix add @stratix/logger\n\n# Validation\nstratix add @stratix/validation\n\n# Caching\nstratix add @stratix/cache\n```\n\n### Testing\n\n```bash\n# Testing utilities\nstratix add @stratix/testing\n```\n\n### Dependency Injection\n\n```bash\n# Awilix (Recommended)\nstratix add @stratix/di-awilix\n```\n\n## Options\n\n| Option | Description | Default |\n|--------|-------------|---------|\n| `--skip-install` | Don't run package manager install | `false` |\n| `--dev` | Install as dev dependency | `false` |\n| `--exact` | Install exact version | `false` |\n\n## What Happens\n\nWhen you add an extension:\n\n1. **Package Installation** - Extension is added to `package.json`\n2. **Configuration** - Creates config files if needed\n3. **Example Code** - Generates usage examples\n4. **Documentation** - Links to extension docs\n\n## Examples\n\n### Add HTTP server\n\n```bash\nstratix add @stratix/http-fastify\n```\n\n**Creates:**\n- `src/infrastructure/http/http.plugin.ts`\n- Example route in `src/infrastructure/http/routes/`\n\n### Add database\n\n```bash\nstratix add @stratix/postgres\n```\n\n**Creates:**\n- `src/infrastructure/persistence/postgres.plugin.ts`\n- Example repository implementation\n\n### Add AI provider\n\n```bash\nstratix add @stratix/ai-openai\n```\n\n**Creates:**\n- `src/infrastructure/ai/openai.plugin.ts`\n- Example agent in `src/domain/agents/`\n\n### Add multiple extensions\n\n```bash\nstratix add @stratix/http-fastify @stratix/postgres @stratix/ai-openai\n```\n\n## Third-Party Extensions\n\n```bash\nstratix add <package-name>\n```\n\nThe CLI will:\n- Install the package\n- Detect if it's a Stratix plugin\n- Generate basic integration code\n\n## Extension Configuration\n\nAfter adding an extension, configure it in `src/main.ts`:\n\n```typescript\nimport { ApplicationBuilder } from '@stratix/runtime';\nimport { FastifyHTTPPlugin } from '@stratix/http-fastify';\nimport { PostgresPlugin } from '@stratix/postgres';\n\nconst app = await ApplicationBuilder.create()\n  .usePlugin(new FastifyHTTPPlugin({ port: 3000 }))\n  .usePlugin(new PostgresPlugin({\n    host: 'localhost',\n    port: 5432,\n    database: 'myapp'\n  }))\n  .build();\n\nawait app.start();\n```\n\n## Best Practices\n\n### 1. Add Extensions Early\n\n```bash\n# Set up infrastructure first\nstratix add @stratix/http-fastify\nstratix add @stratix/postgres\nstratix add @stratix/di-awilix\n```\n\n### 2. Use Official Extensions\n\n```bash\n# ✅ Official, well-maintained\nstratix add @stratix/http-fastify\n\n# ⚠️ Third-party, verify compatibility\nstratix add some-random-plugin\n```\n\n### 3. Skip Install in CI/CD\n\n```bash\nstratix add @stratix/http-fastify --skip-install\n```\n\n## Removing Extensions\n\nTo remove an extension:\n\n```bash\n# Remove package\nnpm uninstall @stratix/http-fastify\n\n# Remove plugin registration from src/main.ts\n# Remove generated files\n```\n\n## Next Steps\n\n- **[CLI Overview](./cli-overview)** - All commands\n- **[Plugin Architecture](../plugins/plugin-architecture)** - Create plugins\n",
      "metadata": {
        "type": "docs",
        "category": "cli",
        "source": "docs/cli/add-command.md",
        "title": "add Command"
      }
    },
    {
      "id": "docs-cli-cli-overview",
      "content": "\n# CLI Overview\n\nThe Stratix CLI (`@stratix/cli`) is a powerful command-line tool for creating projects, generating code, and managing extensions.\n\n## Installation\n\n```bash\n# Global installation\nnpm install -g @stratix/cli\n\n# Or use with npx\nnpx @stratix/cli new my-app\n```\n\n## Available Commands\n\n| Command | Description |\n|---------|-------------|\n| `new` | Create a new Stratix project |\n| `generate` (or `g`) | Generate code (entities, commands, queries, etc.) |\n| `add` | Add extensions to your project |\n| `info` | Display project information |\n\n## Quick Start\n\n```bash\n# Create a new project\nstratix new my-app\n\n# Navigate to project\ncd my-app\n\n# Generate an entity\nstratix generate entity Product\n\n# Add an extension\nstratix add @stratix/http-fastify\n\n# Display project info\nstratix info\n```\n\n## Command Structure\n\n```bash\nstratix <command> [options] [arguments]\n```\n\n### Global Options\n\n```bash\n--help, -h      Show help\n--version, -v   Show version\n```\n\n## Interactive Mode\n\nMost commands support interactive mode when arguments are omitted:\n\n```bash\n# Interactive project creation\nstratix new\n\n# Interactive code generation\nstratix generate\n\n# Interactive extension installation\nstratix add\n```\n\n## Non-Interactive Mode\n\nProvide all arguments for CI/CD pipelines:\n\n```bash\nstratix new my-app --template ddd --skip-install\nstratix generate entity Product --path src/domain/entities\nstratix add @stratix/http-fastify --skip-install\n```\n\n## Project Templates\n\nThe CLI supports multiple project templates:\n\n- **DDD** (Default) - Domain-Driven Design structure\n- **Modular** - Bounded contexts for microservices\n- **Minimal** - Bare-bones setup\n\n```bash\nstratix new my-app --template modular\n```\n\n## Code Generators\n\nGenerate boilerplate code:\n\n- **Entity** - Domain entities\n- **Value Object** - Value objects\n- **Command** - CQRS commands\n- **Query** - CQRS queries\n- **Repository** - Repository interfaces\n- **Quality** - Quality checks (tests, linting)\n\n```bash\nstratix generate entity User\nstratix generate command CreateUser\nstratix generate query GetUserById\n```\n\n## Extension Management\n\nAdd official and third-party extensions:\n\n```bash\n# HTTP server\nstratix add @stratix/http-fastify\n\n# Database\nstratix add @stratix/postgres\n\n# AI providers\nstratix add @stratix/ai-openai\nstratix add @stratix/ai-anthropic\n```\n\n## Configuration\n\nThe CLI reads configuration from:\n\n1. **Command-line flags** (highest priority)\n2. **stratix.config.js** in project root\n3. **package.json** `stratix` field\n4. **Default values** (lowest priority)\n\n### stratix.config.js\n\n```javascript\nmodule.exports = {\n  template: 'ddd',\n  generators: {\n    entity: {\n      path: 'src/domain/entities',\n      suffix: '.entity.ts'\n    },\n    command: {\n      path: 'src/application/commands',\n      suffix: '.command.ts'\n    }\n  }\n};\n```\n\n## Best Practices\n\n### 1. Use Interactive Mode for Learning\n\n```bash\nstratix new  # Learn available options\n```\n\n### 2. Use Non-Interactive for Automation\n\n```bash\nstratix new my-app --template ddd --skip-install\n```\n\n### 3. Customize Generators\n\n```javascript\n// stratix.config.js\nmodule.exports = {\n  generators: {\n    entity: {\n      path: 'src/domain',\n      template: 'custom-entity.hbs'\n    }\n  }\n};\n```\n\n### 4. Version Lock in CI/CD\n\n```bash\nnpx @stratix/cli@0.1.3 new my-app\n```\n\n## Next Steps\n\n- **[new Command](./new-command)** - Create projects\n- **[generate Commands](./generate-commands)** - Code generation\n- **[add Command](./add-command)** - Extension management\n- **[info Command](./info-command)** - Project information\n",
      "metadata": {
        "type": "docs",
        "category": "cli",
        "source": "docs/cli/cli-overview.md",
        "title": "CLI Overview"
      }
    },
    {
      "id": "docs-cli-generate-commands",
      "content": "\n# generate Commands\n\nGenerate boilerplate code with the `generate` (or `g`) command.\n\n## Usage\n\n```bash\nstratix generate <generator> <name> [options]\nstratix g <generator> <name> [options]\n```\n\n## Available Generators\n\n| Generator | Description |\n|-----------|-------------|\n| `entity` | Domain entity |\n| `value-object` | Value object |\n| `command` | CQRS command |\n| `query` | CQRS query |\n| `repository` | Repository interface |\n| `context` | Bounded context (modular architecture) |\n| `quality` | Quality checks (tests, linting) |\n\n## entity Generator\n\nGenerate a domain entity:\n\n```bash\nstratix generate entity Product\nstratix g entity User --path src/domain/entities\n```\n\n**Generated files:**\n- `product.entity.ts` - Entity class\n- `product.entity.spec.ts` - Unit tests\n\n**Example output:**\n\n```typescript\nimport { Entity, EntityId } from '@stratix/core';\n\nexport interface ProductProps {\n  name: string;\n  price: number;\n  stock: number;\n}\n\nexport class Product extends Entity<ProductProps> {\n  private constructor(\n    id: EntityId<'Product'>,\n    props: ProductProps,\n    createdAt: Date,\n    updatedAt: Date\n  ) {\n    super(id, props, createdAt, updatedAt);\n  }\n\n  static create(props: ProductProps): Product {\n    return new Product(\n      EntityId.create<'Product'>(),\n      props,\n      new Date(),\n      new Date()\n    );\n  }\n\n  get name(): string {\n    return this.props.name;\n  }\n\n  get price(): number {\n    return this.props.price;\n  }\n\n  get stock(): number {\n    return this.props.stock;\n  }\n}\n```\n\n## value-object Generator\n\nGenerate a value object:\n\n```bash\nstratix generate value-object Email\nstratix g value-object Price --path src/domain/value-objects\n```\n\n**Generated files:**\n- `email.vo.ts` - Value object class\n- `email.vo.spec.ts` - Unit tests\n\n**Example output:**\n\n```typescript\nimport { ValueObject, Result, Success, Failure } from '@stratix/core';\n\nexport interface EmailProps {\n  value: string;\n}\n\nexport class Email extends ValueObject<EmailProps> {\n  private constructor(props: EmailProps) {\n    super(props);\n  }\n\n  static create(value: string): Result<Email> {\n    if (!value || value.trim().length === 0) {\n      return Failure.create('Email cannot be empty');\n    }\n\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(value)) {\n      return Failure.create('Invalid email format');\n    }\n\n    return Success.create(new Email({ value }));\n  }\n\n  get value(): string {\n    return this.props.value;\n  }\n}\n```\n\n## command Generator\n\nGenerate a CQRS command:\n\n```bash\nstratix generate command CreateProduct\nstratix g command UpdateUser --path src/application/commands\n```\n\n**Generated files:**\n- `create-product.command.ts` - Command class\n- `create-product.handler.ts` - Command handler\n- `create-product.handler.spec.ts` - Unit tests\n\n**Example output:**\n\n```typescript\n// create-product.command.ts\nimport { Command } from '@stratix/core';\n\nexport class CreateProductCommand implements Command {\n  constructor(\n    public readonly name: string,\n    public readonly price: number,\n    public readonly stock: number\n  ) {}\n}\n\n// create-product.handler.ts\nimport { CommandHandler, Result, Success } from '@stratix/core';\nimport { CreateProductCommand } from './create-product.command';\nimport { Product } from '../../domain/entities/product.entity';\n\nexport class CreateProductHandler \n  implements CommandHandler<CreateProductCommand, Product> {\n  \n  constructor(\n    private productRepository: IProductRepository\n  ) {}\n\n  async handle(command: CreateProductCommand): Promise<Result<Product>> {\n    const product = Product.create({\n      name: command.name,\n      price: command.price,\n      stock: command.stock\n    });\n\n    await this.productRepository.save(product);\n\n    return Success.create(product);\n  }\n}\n```\n\n## query Generator\n\nGenerate a CQRS query:\n\n```bash\nstratix generate query GetProductById\nstratix g query GetAllUsers --path src/application/queries\n```\n\n**Generated files:**\n- `get-product-by-id.query.ts` - Query class\n- `get-product-by-id.handler.ts` - Query handler\n- `get-product-by-id.handler.spec.ts` - Unit tests\n\n## repository Generator\n\nGenerate a repository interface:\n\n```bash\nstratix generate repository Product\nstratix g repository User --path src/domain/repositories\n```\n\n**Generated files:**\n- `product.repository.ts` - Repository interface\n- `postgres-product.repository.ts` - PostgreSQL implementation\n\n## context Generator\n\nGenerate a complete bounded context for modular architecture projects:\n\n```bash\nstratix generate context Order\nstratix g context Product --props '[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"number\"}]'\n```\n\n**Generated files:**\n- `order/domain/entities/Order.ts` - Entity/Aggregate root\n- `order/domain/repositories/OrderRepository.ts` - Repository interface\n- `order/infrastructure/repositories/InMemoryOrderRepository.ts` - In-memory implementation\n- `order/application/commands/CreateOrder.ts` - Create command\n- `order/application/commands/CreateOrderHandler.ts` - Command handler\n- `order/application/queries/GetOrderById.ts` - Get by ID query\n- `order/application/queries/GetOrderByIdHandler.ts` - Query handler\n- `order/application/queries/ListOrders.ts` - List query\n- `order/application/queries/ListOrdersHandler.ts` - List handler\n- `order/index.ts` - Barrel exports\n\n**Example output structure:**\n\n```\nsrc/contexts/order/\n├── domain/\n│   ├── entities/\n│   │   └── Order.ts\n│   └── repositories/\n│       └── OrderRepository.ts\n├── application/\n│   ├── commands/\n│   │   ├── CreateOrder.ts\n│   │   └── CreateOrderHandler.ts\n│   └── queries/\n│       ├── GetOrderById.ts\n│       ├── GetOrderByIdHandler.ts\n│       ├── ListOrders.ts\n│       └── ListOrdersHandler.ts\n├── infrastructure/\n│   └── repositories/\n│       └── InMemoryOrderRepository.ts\n└── index.ts\n```\n\n**With properties:**\n\n```bash\nstratix g context Product --props '[\n  {\"name\":\"name\",\"type\":\"string\"},\n  {\"name\":\"price\",\"type\":\"number\"},\n  {\"name\":\"stock\",\"type\":\"number\"}\n]'\n```\n\nThis creates a complete bounded context with the specified properties in the entity. The context generator is ideal for modular monolith projects where you want to keep related functionality together.\n\n**Note:** This generator automatically creates all necessary files and intelligent dependencies. If an entity or repository is missing, it will be created automatically.\n\n## quality Generator\n\nGenerate quality checks:\n\n```bash\nstratix generate quality\nstratix g quality --tests --lint\n```\n\n**Generated files:**\n- `jest.config.js` - Jest configuration\n- `.eslintrc.js` - ESLint rules\n- `.prettierrc` - Prettier config\n\n## Options\n\n| Option | Description | Default |\n|--------|-------------|---------|\n| `--path` | Output directory | Auto-detected |\n| `--skip-tests` | Skip test file generation | `false` |\n| `--dry-run` | Preview without creating files | `false` |\n\n## Examples\n\n### Generate entity with custom path\n\n```bash\nstratix g entity Product --path src/modules/catalog/domain\n```\n\n### Generate command without tests\n\n```bash\nstratix g command CreateProduct --skip-tests\n```\n\n### Preview generation\n\n```bash\nstratix g entity Product --dry-run\n```\n\n## Best Practices\n\n### 1. Use Consistent Naming\n\n```bash\n# ✅ Good: PascalCase\nstratix g entity Product\nstratix g command CreateProduct\n\n# ❌ Bad: inconsistent\nstratix g entity product\nstratix g command create-product\n```\n\n### 2. Organize by Feature\n\n```bash\nstratix g entity Product --path src/domain/entities\nstratix g command CreateProduct --path src/application/commands\n```\n\n### 3. Generate Tests\n\n```bash\n# Always generate tests (default)\nstratix g entity Product\n```\n\n## Next Steps\n\n- **[add Command](./add-command)** - Add extensions\n- **[CLI Overview](./cli-overview)** - All commands\n- **[Domain Modeling](../core-concepts/domain-modeling)** - Entity patterns\n",
      "metadata": {
        "type": "docs",
        "category": "cli",
        "source": "docs/cli/generate-commands.md",
        "title": "generate Commands"
      }
    },
    {
      "id": "docs-cli-info-command",
      "content": "\n# info Command\n\nDisplay comprehensive information about your Stratix project.\n\n## Usage\n\n```bash\nstratix info\n```\n\n## Output\n\nThe `info` command displays:\n\n### Project Information\n\n```\nProject: my-app\nVersion: 1.0.0\nTemplate: ddd\nNode: v20.10.0\nPackage Manager: pnpm\n```\n\n### Stratix Packages\n\n```\n@stratix/core: 0.1.3\n@stratix/runtime: 0.1.3\n@stratix/cli: 0.1.3\n```\n\n### Installed Extensions\n\n```\nExtensions:\n  ✓ @stratix/http-fastify (0.1.3)\n  ✓ @stratix/postgres (0.1.3)\n  ✓ @stratix/ai-openai (0.1.3)\n  ✓ @stratix/di-awilix (0.1.3)\n```\n\n### Project Structure\n\n```\nStructure: DDD\nLayers:\n  ✓ Domain (src/domain)\n  ✓ Application (src/application)\n  ✓ Infrastructure (src/infrastructure)\n```\n\n### Statistics\n\n```\nEntities: 5\nValue Objects: 8\nCommands: 12\nQueries: 10\nRepositories: 5\n```\n\n## Options\n\n| Option | Description |\n|--------|-------------|\n| `--json` | Output as JSON |\n| `--verbose` | Show detailed information |\n\n## JSON Output\n\n```bash\nstratix info --json\n```\n\n```json\n{\n  \"project\": {\n    \"name\": \"my-app\",\n    \"version\": \"1.0.0\",\n    \"template\": \"ddd\"\n  },\n  \"environment\": {\n    \"node\": \"v20.10.0\",\n    \"packageManager\": \"pnpm\"\n  },\n  \"stratix\": {\n    \"core\": \"0.1.3\",\n    \"runtime\": \"0.1.3\",\n    \"cli\": \"0.1.3\"\n  },\n  \"extensions\": [\n    {\n      \"name\": \"@stratix/http-fastify\",\n      \"version\": \"0.1.3\"\n    },\n    {\n      \"name\": \"@stratix/postgres\",\n      \"version\": \"0.1.3\"\n    }\n  ],\n  \"statistics\": {\n    \"entities\": 5,\n    \"valueObjects\": 8,\n    \"commands\": 12,\n    \"queries\": 10,\n    \"repositories\": 5\n  }\n}\n```\n\n## Verbose Output\n\n```bash\nstratix info --verbose\n```\n\nShows additional information:\n- TypeScript configuration\n- ESLint configuration\n- Test configuration\n- Build configuration\n- Environment variables\n\n## Use Cases\n\n### 1. Debugging\n\n```bash\nstratix info --verbose > debug.txt\n```\n\n### 2. CI/CD Verification\n\n```bash\nstratix info --json | jq '.stratix.core'\n```\n\n### 3. Documentation\n\n```bash\nstratix info > PROJECT_INFO.md\n```\n\n### 4. Version Checking\n\n```bash\nstratix info | grep \"@stratix/core\"\n```\n\n## Troubleshooting\n\n### Command Not Found\n\n```bash\n# Install CLI globally\nnpm install -g @stratix/cli\n\n# Or use npx\nnpx @stratix/cli info\n```\n\n### Incorrect Information\n\n```bash\n# Clear cache and re-run\nrm -rf node_modules/.cache\nstratix info\n```\n\n## Next Steps\n\n- **[CLI Overview](./cli-overview)** - All commands\n- **[new Command](./new-command)** - Create projects\n- **[generate Commands](./generate-commands)** - Generate code\n",
      "metadata": {
        "type": "docs",
        "category": "cli",
        "source": "docs/cli/info-command.md",
        "title": "info Command"
      }
    },
    {
      "id": "docs-cli-new-command",
      "content": "\n# new Command\n\nCreate a new Stratix project with the `new` command.\n\n## Usage\n\n```bash\nstratix new <project-name> [options]\n```\n\n## Interactive Mode\n\n```bash\nstratix new\n```\n\nYou'll be prompted for:\n- Project name\n- Project template (DDD, Modular, Minimal)\n- Package manager (npm, pnpm, yarn)\n- Install dependencies (yes/no)\n\n## Non-Interactive Mode\n\n```bash\nstratix new my-app --template ddd --pm pnpm --skip-install\n```\n\n## Options\n\n| Option | Alias | Description | Default |\n|--------|-------|-------------|---------|\n| `--template` | `-t` | Project template | `ddd` |\n| `--package-manager` | `--pm` | Package manager | `npm` |\n| `--skip-install` | | Skip dependency installation | `false` |\n| `--skip-git` | | Skip git initialization | `false` |\n| `--directory` | `-d` | Target directory | `<project-name>` |\n\n## Templates\n\n### DDD Template (Default)\n\nDomain-Driven Design structure:\n\n```bash\nstratix new my-app --template ddd\n```\n\n**Structure:**\n```\nmy-app/\n├── src/\n│   ├── domain/\n│   │   ├── entities/\n│   │   ├── value-objects/\n│   │   └── services/\n│   ├── application/\n│   │   ├── commands/\n│   │   └── queries/\n│   ├── infrastructure/\n│   │   ├── persistence/\n│   │   └── http/\n│   └── main.ts\n├── tests/\n├── package.json\n└── tsconfig.json\n```\n\n### Modular Template\n\nBounded contexts for microservices:\n\n```bash\nstratix new my-app --template modular\n```\n\n**Structure:**\n```\nmy-app/\n├── src/\n│   ├── contexts/\n│   │   ├── products/\n│   │   │   ├── domain/\n│   │   │   ├── application/\n│   │   │   └── infrastructure/\n│   │   └── orders/\n│   │       ├── domain/\n│   │       ├── application/\n│   │       └── infrastructure/\n│   └── main.ts\n├── tests/\n├── package.json\n└── tsconfig.json\n```\n\n### Minimal Template\n\nBare-bones setup:\n\n```bash\nstratix new my-app --template minimal\n```\n\n**Structure:**\n```\nmy-app/\n├── src/\n│   └── main.ts\n├── package.json\n└── tsconfig.json\n```\n\n## Examples\n\n### Create with pnpm\n\n```bash\nstratix new my-app --pm pnpm\n```\n\n### Create without installing\n\n```bash\nstratix new my-app --skip-install\ncd my-app\npnpm install\n```\n\n### Create in specific directory\n\n```bash\nstratix new my-app --directory ./projects/my-app\n```\n\n### Create modular project\n\n```bash\nstratix new my-microservices --template modular\n```\n\n## What Gets Created\n\n### Files\n\n- `package.json` - Project metadata and dependencies\n- `tsconfig.json` - TypeScript configuration\n- `.eslintrc.js` - ESLint configuration\n- `.prettierrc` - Prettier configuration\n- `.gitignore` - Git ignore rules\n- `README.md` - Project documentation\n- `src/main.ts` - Application entry point\n\n### Dependencies\n\n**Core:**\n- `@stratix/core` - Core framework\n- `@stratix/runtime` - Application runtime\n\n**Dev Dependencies:**\n- `typescript` - TypeScript compiler\n- `@types/node` - Node.js type definitions\n- `eslint` - Linting\n- `prettier` - Code formatting\n- `jest` - Testing framework\n\n## Post-Creation Steps\n\nAfter creating a project:\n\n```bash\ncd my-app\n\n# Install dependencies (if skipped)\nnpm install\n\n# Add extensions\nstratix add @stratix/http-fastify\nstratix add @stratix/postgres\n\n# Generate code\nstratix generate entity Product\n\n# Build\nnpm run build\n\n# Run\nnpm start\n```\n\n## Best Practices\n\n### 1. Use DDD Template for Most Projects\n\n```bash\nstratix new my-app --template ddd\n```\n\n### 2. Use Modular for Microservices\n\n```bash\nstratix new my-services --template modular\n```\n\n### 3. Choose Package Manager Wisely\n\n```bash\n# pnpm - Fast, efficient\nstratix new my-app --pm pnpm\n\n# npm - Standard\nstratix new my-app --pm npm\n\n# yarn - Alternative\nstratix new my-app --pm yarn\n```\n\n### 4. Skip Install in CI/CD\n\n```bash\nstratix new my-app --skip-install\n```\n\n## Next Steps\n\n- **[generate Commands](./generate-commands)** - Generate code\n- **[add Command](./add-command)** - Add extensions\n- **[Project Structure](../getting-started/project-structure)** - Understand structure\n",
      "metadata": {
        "type": "docs",
        "category": "cli",
        "source": "docs/cli/new-command.md",
        "title": "new Command"
      }
    },
    {
      "id": "docs-core-concepts-architecture-overview",
      "content": "\n# Architecture Overview\n\nStratix is built on **Hexagonal Architecture** (Ports and Adapters) combined with **Domain-Driven Design** principles to create maintainable, testable, and scalable applications.\n\n## Hexagonal Architecture\n\nAlso known as **Ports and Adapters**, this architecture pattern separates your business logic from external concerns.\n\n```mermaid\ngraph TB\n    subgraph \"External World\"\n        HTTP[HTTP/REST]\n        DB[(Database)]\n        MQ[Message Queue]\n        AI[AI Services]\n    end\n    \n    subgraph \"Application Core\"\n        Domain[Domain Layer<br/>Entities, Value Objects]\n        Application[Application Layer<br/>Use Cases, CQRS]\n    end\n    \n    subgraph \"Infrastructure\"\n        HTTPAdapter[HTTP Adapter]\n        DBAdapter[Database Adapter]\n        MQAdapter[Message Adapter]\n        AIAdapter[AI Adapter]\n    end\n    \n    HTTP --> HTTPAdapter\n    HTTPAdapter --> Application\n    Application --> Domain\n    Application --> DBAdapter\n    DBAdapter --> DB\n    Application --> MQAdapter\n    MQAdapter --> MQ\n    Application --> AIAdapter\n    AIAdapter --> AI\n```\n\n### Core Principles\n\n1. **Business Logic is Independent** - Domain code doesn't depend on frameworks or infrastructure\n2. **Dependency Inversion** - Infrastructure depends on domain, not vice versa\n3. **Testability** - Easy to test business logic in isolation\n4. **Flexibility** - Swap implementations without changing business logic\n\n## The Three Layers\n\n### 1. Domain Layer (Core)\n\n**Purpose**: Pure business logic\n\n**Contains:**\n- Entities and Aggregate Roots\n- Value Objects\n- Domain Services\n- Domain Events\n- Repository Interfaces\n\n**Rules:**\n- ❌ No dependencies on other layers\n- ❌ No framework code\n- ❌ No infrastructure concerns\n- ✅ Pure TypeScript/JavaScript\n- ✅ Business rules only\n\n**Example:**\n```typescript\n// src/domain/entities/Order.ts\nimport { AggregateRoot, EntityId, DomainEvent } from '@stratix/core';\n\nexport class Order extends AggregateRoot<'Order'> {\n  private items: OrderItem[] = [];\n  private status: OrderStatus = OrderStatus.PENDING;\n\n  addItem(item: OrderItem): void {\n    if (this.status !== OrderStatus.PENDING) {\n      throw new Error('Cannot add items to non-pending order');\n    }\n    \n    this.items.push(item);\n    this.addDomainEvent(new OrderItemAddedEvent(this.id, item));\n  }\n\n  calculateTotal(): Money {\n    return this.items.reduce(\n      (total, item) => total.add(item.price.multiply(item.quantity)),\n      Money.USD(0)\n    );\n  }\n}\n```\n\n### 2. Application Layer (Use Cases)\n\n**Purpose**: Orchestrate domain objects to fulfill use cases\n\n**Contains:**\n- Commands and Command Handlers\n- Queries and Query Handlers\n- Application Services\n- DTOs (Data Transfer Objects)\n\n**Rules:**\n- ✅ Depends on Domain layer\n- ❌ No dependencies on Infrastructure\n- ✅ Orchestrates domain objects\n- ✅ Implements use cases\n\n**Example:**\n```typescript\n// src/application/commands/CreateOrder.ts\nimport { Command } from '@stratix/core';\n\nexport class CreateOrderCommand implements Command {\n  constructor(\n    public readonly customerId: string,\n    public readonly items: OrderItemDTO[]\n  ) {}\n}\n\n// src/application/handlers/CreateOrderHandler.ts\nimport { CommandHandler, Result, Success, Failure } from '@stratix/core';\n\nexport class CreateOrderHandler \n  implements CommandHandler<CreateOrderCommand, Order> {\n  \n  constructor(\n    private orderRepository: IOrderRepository,\n    private productRepository: IProductRepository\n  ) {}\n\n  async handle(command: CreateOrderCommand): Promise<Result<Order>> {\n    // Validate products exist\n    for (const item of command.items) {\n      const product = await this.productRepository.findById(item.productId);\n      if (!product) {\n        return Failure.create(new Error(`Product ${item.productId} not found`));\n      }\n    }\n\n    // Create order (domain logic)\n    const order = Order.create(\n      EntityId.create<'Order'>(),\n      command.customerId,\n      command.items\n    );\n\n    // Persist\n    await this.orderRepository.save(order);\n\n    return Success.create(order);\n  }\n}\n```\n\n### 3. Infrastructure Layer (Technical Details)\n\n**Purpose**: Implement technical details and external integrations\n\n**Contains:**\n- Repository Implementations\n- HTTP Controllers\n- Database Configurations\n- External Service Clients\n- Message Broker Integrations\n\n**Rules:**\n- ✅ Depends on Domain and Application layers\n- ✅ Framework-specific code\n- ✅ External integrations\n- ✅ Technical implementations\n\n**Example:**\n```typescript\n// src/infrastructure/repositories/PostgresOrderRepository.ts\nimport { IOrderRepository } from '../../domain/repositories/IOrderRepository';\n\nexport class PostgresOrderRepository implements IOrderRepository {\n  constructor(private db: Database) {}\n\n  async save(order: Order): Promise<void> {\n    await this.db.transaction(async (trx) => {\n      // Save order\n      await trx('orders').insert({\n        id: order.id,\n        customer_id: order.customerId,\n        status: order.status,\n        total: order.calculateTotal().amount,\n        created_at: order.createdAt\n      });\n\n      // Save order items\n      for (const item of order.items) {\n        await trx('order_items').insert({\n          order_id: order.id,\n          product_id: item.productId,\n          quantity: item.quantity,\n          price: item.price.amount\n        });\n      }\n    });\n  }\n\n  async findById(id: EntityId<'Order'>): Promise<Order | null> {\n    const row = await this.db('orders').where({ id }).first();\n    return row ? this.toDomain(row) : null;\n  }\n}\n```\n\n## Dependency Flow\n\n```mermaid\ngraph LR\n    Infrastructure -->|depends on| Application\n    Application -->|depends on| Domain\n    Domain -->|depends on| Nothing\n    \n    style Domain fill:#4CAF50\n    style Application fill:#2196F3\n    style Infrastructure fill:#FF9800\n```\n\n### Dependency Inversion Principle\n\nThe key is that **dependencies point inward**:\n\n```typescript\n// ✅ Good: Infrastructure depends on Domain\nexport class PostgresOrderRepository implements IOrderRepository {\n  // IOrderRepository is defined in Domain layer\n}\n\n// ❌ Bad: Domain depends on Infrastructure\nexport class Order {\n  async save() {\n    await PostgresDatabase.query('INSERT...'); // Domain shouldn't know about Postgres\n  }\n}\n```\n\n## CQRS Integration\n\nStratix uses **CQRS** (Command Query Responsibility Segregation) to separate reads and writes:\n\n```mermaid\ngraph TB\n    Client[Client]\n    \n    subgraph \"Write Side\"\n        Command[Command]\n        CommandHandler[Command Handler]\n        Domain[Domain Model]\n        WriteDB[(Write Database)]\n    end\n    \n    subgraph \"Read Side\"\n        Query[Query]\n        QueryHandler[Query Handler]\n        ReadDB[(Read Database)]\n    end\n    \n    Client -->|Create/Update/Delete| Command\n    Command --> CommandHandler\n    CommandHandler --> Domain\n    Domain --> WriteDB\n    \n    Client -->|Get/List| Query\n    Query --> QueryHandler\n    QueryHandler --> ReadDB\n    \n    WriteDB -.->|Sync| ReadDB\n```\n\n### Commands (Write)\n\n```typescript\n// Modify state\nconst result = await commandBus.dispatch(\n  new CreateOrderCommand(customerId, items)\n);\n```\n\n### Queries (Read)\n\n```typescript\n// Read state\nconst result = await queryBus.execute(\n  new GetOrderByIdQuery(orderId)\n);\n```\n\n## Plugin Architecture\n\nStratix extends functionality through plugins:\n\n```typescript\nimport { ApplicationBuilder } from '@stratix/runtime';\n\nconst app = await ApplicationBuilder.create()\n  .useContainer(new AwilixContainer())\n  .useLogger(new ConsoleLogger())\n  \n  // Infrastructure plugins\n  .usePlugin(new PostgresPlugin({ /* config */ }))\n  .usePlugin(new FastifyHTTPPlugin({ port: 3000 }))\n  .usePlugin(new RabbitMQPlugin({ /* config */ }))\n  \n  // Domain modules\n  .useModule(new OrdersModule())\n  .useModule(new ProductsModule())\n  \n  .build();\n\nawait app.start();\n```\n\n## Bounded Contexts\n\nOrganize code by business domains (bounded contexts):\n\n```\nsrc/\n├── modules/\n│   ├── orders/              # Orders Bounded Context\n│   │   ├── domain/\n│   │   ├── application/\n│   │   └── infrastructure/\n│   │\n│   ├── products/            # Products Bounded Context\n│   │   ├── domain/\n│   │   ├── application/\n│   │   └── infrastructure/\n│   │\n│   └── customers/           # Customers Bounded Context\n│       ├── domain/\n│       ├── application/\n│       └── infrastructure/\n```\n\nEach context is **portable** - works in monolith or microservice.\n\n## Complete Example\n\n### Domain Layer\n\n```typescript\n// domain/entities/Product.ts\nexport class Product extends AggregateRoot<'Product'> {\n  constructor(\n    id: EntityId<'Product'>,\n    private name: string,\n    private price: Money,\n    createdAt: Date,\n    updatedAt: Date\n  ) {\n    super(id, createdAt, updatedAt);\n  }\n\n  updatePrice(newPrice: Money): void {\n    if (newPrice.amount <= 0) {\n      throw new Error('Price must be positive');\n    }\n    this.price = newPrice;\n    this.touch();\n    this.addDomainEvent(new ProductPriceChangedEvent(this.id, newPrice));\n  }\n}\n\n// domain/repositories/IProductRepository.ts\nexport interface IProductRepository {\n  save(product: Product): Promise<void>;\n  findById(id: EntityId<'Product'>): Promise<Product | null>;\n  findAll(): Promise<Product[]>;\n}\n```\n\n### Application Layer\n\n```typescript\n// application/commands/UpdateProductPrice.ts\nexport class UpdateProductPriceCommand implements Command {\n  constructor(\n    public readonly productId: string,\n    public readonly newPrice: number\n  ) {}\n}\n\n// application/handlers/UpdateProductPriceHandler.ts\nexport class UpdateProductPriceHandler \n  implements CommandHandler<UpdateProductPriceCommand, Product> {\n  \n  constructor(private productRepository: IProductRepository) {}\n\n  async handle(command: UpdateProductPriceCommand): Promise<Result<Product>> {\n    const product = await this.productRepository.findById(command.productId);\n    \n    if (!product) {\n      return Failure.create(new Error('Product not found'));\n    }\n\n    product.updatePrice(Money.USD(command.newPrice));\n    await this.productRepository.save(product);\n\n    return Success.create(product);\n  }\n}\n```\n\n### Infrastructure Layer\n\n```typescript\n// infrastructure/http/ProductController.ts\nexport class ProductController {\n  constructor(\n    private commandBus: CommandBus,\n    private queryBus: QueryBus\n  ) {}\n\n  async updatePrice(request: Request): Promise<Response> {\n    const { id } = request.params;\n    const { price } = request.body;\n\n    const result = await this.commandBus.dispatch(\n      new UpdateProductPriceCommand(id, price)\n    );\n\n    if (result.isFailure) {\n      throw HttpErrorImpl.badRequest(result.error.message);\n    }\n\n    return { statusCode: 200, body: result.value };\n  }\n}\n\n// infrastructure/repositories/PostgresProductRepository.ts\nexport class PostgresProductRepository implements IProductRepository {\n  constructor(private db: Database) {}\n\n  async save(product: Product): Promise<void> {\n    await this.db('products')\n      .insert({\n        id: product.id,\n        name: product.name,\n        price: product.price.amount,\n        updated_at: product.updatedAt\n      })\n      .onConflict('id')\n      .merge();\n  }\n\n  async findById(id: EntityId<'Product'>): Promise<Product | null> {\n    const row = await this.db('products').where({ id }).first();\n    return row ? this.toDomain(row) : null;\n  }\n}\n```\n\n## Benefits\n\n### 1. Testability\n\n```typescript\n// Test domain logic without infrastructure\ndescribe('Product', () => {\n  it('should update price', () => {\n    const product = new Product(/* ... */);\n    product.updatePrice(Money.USD(99.99));\n    expect(product.price.amount).toBe(99.99);\n  });\n});\n\n// Test application logic with mocks\ndescribe('UpdateProductPriceHandler', () => {\n  it('should update product price', async () => {\n    const mockRepo = {\n      findById: jest.fn().mockResolvedValue(product),\n      save: jest.fn()\n    };\n    \n    const handler = new UpdateProductPriceHandler(mockRepo);\n    const result = await handler.handle(command);\n    \n    expect(result.isSuccess).toBe(true);\n    expect(mockRepo.save).toHaveBeenCalled();\n  });\n});\n```\n\n### 2. Flexibility\n\n```typescript\n// Easy to swap implementations\n// Development: In-memory\n.usePlugin(new InMemoryDatabasePlugin())\n\n// Production: PostgreSQL\n.usePlugin(new PostgresPlugin({ /* config */ }))\n\n// Domain code doesn't change!\n```\n\n### 3. Maintainability\n\n- Clear separation of concerns\n- Easy to locate code\n- Changes are localized\n- Reduced coupling\n\n## Next Steps\n\n- **[Domain Modeling](./domain-modeling)** - Learn about entities and value objects\n- **[Bounded Contexts](./bounded-contexts)** - Modular architecture\n- **[CQRS](./cqrs)** - Command Query Responsibility Segregation\n- **[Result Pattern](./result-pattern)** - Error handling\n- **[Dependency Injection](./dependency-injection)** - DI container\n",
      "metadata": {
        "type": "docs",
        "category": "core-concepts",
        "source": "docs/core-concepts/architecture-overview.md",
        "title": "Architecture Overview"
      }
    },
    {
      "id": "docs-core-concepts-bounded-contexts",
      "content": "\n# Bounded Contexts\n\nOne of Stratix's most powerful features is **Bounded Contexts** - self-contained domain modules that work seamlessly in both monolithic and microservices architectures.\n\n> [!IMPORTANT]\n> **The Modular Advantage**\n> \n> Start with a modular monolith and migrate to microservices **only when necessary**. Stratix makes this transition seamless because bounded contexts are portable by design.\n\n## What are Bounded Contexts?\n\nA **Bounded Context** is a self-contained module that encapsulates:\n- Domain logic (entities, value objects, domain services)\n- Application logic (commands, queries, handlers)\n- Infrastructure (repositories, external integrations)\n- Clear boundaries and interfaces\n\n### Key Benefits\n\n**Start Simple** - Build as a monolith, deploy as one application  \n**Scale Gradually** - Extract contexts to microservices when needed  \n**Team Autonomy** - Each team owns a bounded context  \n**Clear Boundaries** - No accidental coupling between domains  \n**Portable** - Same code works in monolith or microservice  \n\n## The Migration Path\n\n```mermaid\ngraph LR\n    A[Modular Monolith] -->|When needed| B[Hybrid Architecture]\n    B -->|When needed| C[Microservices]\n    \n    style A fill:#4CAF50\n    style B fill:#FF9800\n    style C fill:#2196F3\n```\n\n### Phase 1: Modular Monolith (Start Here)\n\n**Perfect for:**\n- New projects\n- Small to medium teams\n- Rapid development\n- Uncertain scaling needs\n\n**Architecture:**\n```\nSingle Application\n├── Products Context\n├── Orders Context\n├── Customers Context\n└── Inventory Context\n\nAll contexts run in the same process\n```\n\n**Benefits:**\n- Simple deployment\n- Shared database transactions\n- Fast inter-context communication\n- Easy debugging\n- Lower operational complexity\n\n### Phase 2: Hybrid Architecture (Scale Strategically)\n\n**Perfect for:**\n- Growing applications\n- Specific scaling needs\n- Team growth\n\n**Architecture:**\n```\nMain Application (Monolith)\n├── Products Context\n├── Orders Context\n└── Customers Context\n\nSeparate Service (Microservice)\n└── Inventory Context (high load)\n```\n\n**Benefits:**\n- Scale only what needs scaling\n- Gradual migration\n- Lower risk\n- Maintain monolith benefits where possible\n\n### Phase 3: Microservices (When Necessary)\n\n**Perfect for:**\n- Large teams\n- High scale requirements\n- Independent deployment needs\n\n**Architecture:**\n```\nProducts Service\nOrders Service\nCustomers Service\nInventory Service\n\nEach context is a separate service\n```\n\n**Benefits:**\n- Independent scaling\n- Independent deployment\n- Technology diversity\n- Team autonomy\n\n## Context Module Interface\n\nStratix provides the `ContextModule` interface for defining bounded contexts:\n\n```typescript\nimport { ContextModule, ModuleMetadata, ModuleContext } from '@stratix/core';\n\nexport class ProductsModule implements ContextModule {\n  readonly metadata: ModuleMetadata = {\n    name: 'products-context',\n    version: '1.0.0',\n    description: 'Products Bounded Context',\n    requiredPlugins: ['postgres', 'rabbitmq'],\n    requiredModules: [] // Dependencies on other contexts\n  };\n\n  readonly contextName = 'Products';\n\n  async initialize(context: ModuleContext): Promise<void> {\n    // Register repositories, services, etc.\n    const repository = new PostgresProductRepository(context.container);\n    context.container.register('productRepository', () => repository);\n  }\n\n  getCommands(): CommandDefinition[] {\n    return [\n      {\n        name: 'CreateProduct',\n        commandType: CreateProductCommand,\n        handler: new CreateProductHandler(/* dependencies */)\n      }\n    ];\n  }\n\n  getQueries(): QueryDefinition[] {\n    return [\n      {\n        name: 'GetProductById',\n        queryType: GetProductByIdQuery,\n        handler: new GetProductByIdHandler(/* dependencies */)\n      }\n    ];\n  }\n\n  getEventHandlers(): EventHandlerDefinition[] {\n    return [\n      {\n        eventType: 'ProductCreated',\n        handler: new ProductCreatedHandler(/* dependencies */)\n      }\n    ];\n  }\n}\n```\n\n## Example: Modular Monolith\n\n### Project Structure\n\n```\nmy-ecommerce/\n├── src/\n│   ├── modules/\n│   │   ├── products/           # Products Context\n│   │   │   ├── domain/\n│   │   │   ├── application/\n│   │   │   ├── infrastructure/\n│   │   │   └── ProductsModule.ts\n│   │   │\n│   │   ├── orders/             # Orders Context\n│   │   │   ├── domain/\n│   │   │   ├── application/\n│   │   │   ├── infrastructure/\n│   │   │   └── OrdersModule.ts\n│   │   │\n│   │   └── customers/          # Customers Context\n│   │       ├── domain/\n│   │       ├── application/\n│   │       ├── infrastructure/\n│   │       └── CustomersModule.ts\n│   │\n│   └── index.ts                # Application entry point\n```\n\n### Application Setup (Monolith)\n\n```typescript\n// src/index.ts\nimport { ApplicationBuilder } from '@stratix/runtime';\nimport { ProductsModule } from './modules/products/ProductsModule';\nimport { OrdersModule } from './modules/orders/OrdersModule';\nimport { CustomersModule } from './modules/customers/CustomersModule';\n\nconst app = await ApplicationBuilder.create()\n  .useContainer(new AwilixContainer())\n  .useLogger(new ConsoleLogger())\n  \n  // Infrastructure plugins\n  .usePlugin(new PostgresPlugin({ /* config */ }))\n  .usePlugin(new FastifyHTTPPlugin({ port: 3000 }))\n  \n  // Bounded contexts - all in one application\n  .useModule(new ProductsModule())\n  .useModule(new OrdersModule())\n  .useModule(new CustomersModule())\n  \n  .build();\n\nawait app.start();\n// All contexts running in the same process! \n```\n\n## Migrating to Microservices\n\n### Step 1: Identify the Context to Extract\n\nLet's say `OrdersModule` needs independent scaling:\n\n```typescript\n// Before: Monolith with all contexts\n.useModule(new ProductsModule())\n.useModule(new OrdersModule())      // ← Extract this\n.useModule(new CustomersModule())\n```\n\n### Step 2: Create a Separate Service\n\n**orders-service/src/index.ts:**\n```typescript\nimport { ApplicationBuilder } from '@stratix/runtime';\nimport { OrdersModule } from './modules/orders/OrdersModule';\n\n// Orders microservice - SAME MODULE CODE!\nconst app = await ApplicationBuilder.create()\n  .useContainer(new AwilixContainer())\n  .useLogger(new ConsoleLogger())\n  \n  .usePlugin(new PostgresPlugin({ /* config */ }))\n  .usePlugin(new FastifyHTTPPlugin({ port: 3001 }))\n  .usePlugin(new RabbitMQPlugin({ /* config */ }))\n  \n  // Same OrdersModule, different service!\n  .useModule(new OrdersModule())\n  \n  .build();\n\nawait app.start();\n```\n\n### Step 3: Update the Main Application\n\n**main-app/src/index.ts:**\n```typescript\nconst app = await ApplicationBuilder.create()\n  .useContainer(new AwilixContainer())\n  .useLogger(new ConsoleLogger())\n  \n  .usePlugin(new PostgresPlugin({ /* config */ }))\n  .usePlugin(new FastifyHTTPPlugin({ port: 3000 }))\n  .usePlugin(new RabbitMQPlugin({ /* config */ }))\n  \n  // Remove OrdersModule from here\n  .useModule(new ProductsModule())\n  .useModule(new CustomersModule())\n  \n  .build();\n\nawait app.start();\n```\n\n### Step 4: Inter-Service Communication\n\nUse events for communication between services:\n\n```typescript\n// In ProductsModule (main app)\nclass ProductCreatedHandler implements EventHandler<ProductCreatedEvent> {\n  constructor(private eventBus: EventBus) {}\n\n  async handle(event: ProductCreatedEvent): Promise<void> {\n    // Publish event to message broker\n    await this.eventBus.publish(event);\n    // OrdersService will receive this event via RabbitMQ\n  }\n}\n\n// In OrdersModule (separate service)\nclass ProductCreatedHandler implements EventHandler<ProductCreatedEvent> {\n  async handle(event: ProductCreatedEvent): Promise<void> {\n    // React to product creation\n    console.log('Product created:', event.productId);\n  }\n}\n```\n\n## Context Dependencies\n\n### Declaring Dependencies\n\n```typescript\nexport class OrdersModule implements ContextModule {\n  readonly metadata: ModuleMetadata = {\n    name: 'orders-context',\n    version: '1.0.0',\n    \n    // Require these plugins\n    requiredPlugins: ['postgres', 'rabbitmq'],\n    \n    // Depend on these contexts (in monolith)\n    requiredModules: ['products-context', 'customers-context']\n  };\n}\n```\n\n### Dependency Resolution\n\nStratix automatically:\n- Initializes contexts in dependency order\n- Validates all dependencies are present\n- Detects circular dependencies\n- Provides clear error messages\n\n## Communication Patterns\n\n### In Monolith: Direct Communication\n\n```typescript\n// Direct method calls - fast and simple\nclass CreateOrderHandler implements CommandHandler<CreateOrderCommand> {\n  constructor(\n    private productRepository: IProductRepository,\n    private customerRepository: ICustomerRepository\n  ) {}\n\n  async handle(command: CreateOrderCommand): Promise<Result<Order>> {\n    // Direct repository access - same process\n    const product = await this.productRepository.findById(command.productId);\n    const customer = await this.customerRepository.findById(command.customerId);\n    \n    // Create order\n    const order = new Order(/* ... */);\n    return Success.create(order);\n  }\n}\n```\n\n### In Microservices: Event-Driven Communication\n\n```typescript\n// Event-driven - decoupled services\nclass CreateOrderHandler implements CommandHandler<CreateOrderCommand> {\n  constructor(\n    private eventBus: EventBus,\n    private httpClient: HttpClient\n  ) {}\n\n  async handle(command: CreateOrderCommand): Promise<Result<Order>> {\n    // HTTP call to Products service\n    const product = await this.httpClient.get(\n      `http://products-service/api/products/${command.productId}`\n    );\n    \n    // Create order\n    const order = new Order(/* ... */);\n    \n    // Publish event\n    await this.eventBus.publish(new OrderCreatedEvent(order));\n    \n    return Success.create(order);\n  }\n}\n```\n\n## Best Practices\n\n### 1. Start with a Modular Monolith\n\n```typescript\n// Good: Start simple\nconst app = await ApplicationBuilder.create()\n  .useModule(new ProductsModule())\n  .useModule(new OrdersModule())\n  .useModule(new CustomersModule())\n  .build();\n```\n\n### 2. Design for Portability\n\n```typescript\n// Good: Use interfaces, not concrete implementations\nclass OrdersModule {\n  getCommands() {\n    return [{\n      handler: new CreateOrderHandler(\n        this.container.resolve('productRepository'), // Interface\n        this.container.resolve('customerRepository')  // Interface\n      )\n    }];\n  }\n}\n\n// ❌ Bad: Hard-coded dependencies\nclass OrdersModule {\n  getCommands() {\n    return [{\n      handler: new CreateOrderHandler(\n        new PostgresProductRepository(), // Concrete class\n        new PostgresCustomerRepository()  // Concrete class\n      )\n    }];\n  }\n}\n```\n\n### 3. Use Events for Cross-Context Communication\n\n```typescript\n// Good: Event-driven (works in monolith and microservices)\nawait this.eventBus.publish(new ProductCreatedEvent(product));\n\n// ⚠️ Acceptable in monolith, breaks in microservices\nconst order = await this.orderRepository.findByProductId(productId);\n```\n\n### 4. Keep Contexts Independent\n\nEach bounded context should have its own database schema and tables. Avoid sharing database tables between contexts, as this creates tight coupling and makes contexts harder to evolve independently.\n\n## Real-World Example\n\n### Scenario: E-Commerce Platform\n\n**Start (Day 1):** Modular Monolith\n```\nSingle Application (1 server)\n├── Products Context\n├── Orders Context\n├── Customers Context\n└── Inventory Context\n\nCost: $50/month\nComplexity: Low\nTeam: 3 developers\n```\n\n**Growth (Month 6):** Hybrid Architecture\n```\nMain Application (1 server)\n├── Products Context\n├── Orders Context\n└── Customers Context\n\nInventory Service (2 servers - high load)\n└── Inventory Context\n\nCost: $200/month\nComplexity: Medium\nTeam: 6 developers\n```\n\n**Scale (Year 2):** Microservices\n```\nProducts Service (2 servers)\nOrders Service (3 servers - high load)\nCustomers Service (1 server)\nInventory Service (2 servers)\n\nCost: $800/month\nComplexity: High\nTeam: 15 developers (3-4 per service)\n```\n\n## Migration Checklist\n\nWhen extracting a context to a microservice:\n\n- [ ] Identify context boundaries\n- [ ] Review context dependencies\n- [ ] Set up message broker (RabbitMQ)\n- [ ] Replace direct calls with events/HTTP\n- [ ] Set up separate database\n- [ ] Configure deployment pipeline\n- [ ] Update monitoring and logging\n- [ ] Test inter-service communication\n- [ ] Gradual rollout (canary deployment)\n\n## Next Steps\n\n- **[Architecture Overview](./architecture-overview)** - Hexagonal architecture\n- **[Domain Modeling](./domain-modeling)** - Domain entities\n- **[CQRS](./cqrs)** - Command and query patterns\n- **[Plugin System](../plugins/plugin-architecture)** - Plugin architecture\n",
      "metadata": {
        "type": "docs",
        "category": "core-concepts",
        "source": "docs/core-concepts/bounded-contexts.md",
        "title": "Bounded Contexts"
      }
    },
    {
      "id": "docs-core-concepts-cqrs",
      "content": "\n# CQRS\n\n**CQRS** (Command Query Responsibility Segregation) is a pattern that separates read and write operations into different models.\n\n## The Principle\n\n> **Commands** change state. **Queries** return state. Never do both.\n\n```mermaid\ngraph LR\n    Client[Client]\n    \n    subgraph \"Write Model\"\n        Command[Command]\n        CommandHandler[Command Handler]\n        WriteDB[(Write DB)]\n    end\n    \n    subgraph \"Read Model\"\n        Query[Query]\n        QueryHandler[Query Handler]\n        ReadDB[(Read DB)]\n    end\n    \n    Client -->|Execute| Command\n    Command --> CommandHandler\n    CommandHandler --> WriteDB\n    \n    Client -->|Execute| Query\n    Query --> QueryHandler\n    QueryHandler --> ReadDB\n    \n    WriteDB -.->|Sync| ReadDB\n```\n\n## Commands (Write Operations)\n\nCommands represent **intentions to change state**.\n\n### Characteristics\n\n- ✅ Imperative names (CreateProduct, UpdateOrder)\n- ✅ Contain data needed for the operation\n- ✅ Return `Result<T>` (success or failure)\n- ✅ May fail (validation, business rules)\n\n### Example\n\n```typescript\nimport { Command } from '@stratix/core';\n\nexport class CreateProductCommand implements Command {\n  constructor(\n    public readonly name: string,\n    public readonly price: number,\n    public readonly stock: number\n  ) {}\n}\n```\n\n### Command Handler\n\n```typescript\nimport { CommandHandler, Result, Success, Failure } from '@stratix/core';\n\nexport class CreateProductHandler \n  implements CommandHandler<CreateProductCommand, Product> {\n  \n  constructor(\n    private productRepository: IProductRepository,\n    private eventBus: EventBus\n  ) {}\n\n  async handle(command: CreateProductCommand): Promise<Result<Product>> {\n    // Validation\n    if (command.price <= 0) {\n      return Failure.create(new Error('Price must be positive'));\n    }\n\n    // Create entity\n    const product = new Product(\n      EntityId.create<'Product'>(),\n      command.name,\n      Money.USD(command.price),\n      command.stock,\n      new Date(),\n      new Date()\n    );\n\n    // Persist\n    await this.productRepository.save(product);\n\n    // Publish events\n    const events = product.getDomainEvents();\n    for (const event of events) {\n      await this.eventBus.publish(event);\n    }\n\n    return Success.create(product);\n  }\n}\n```\n\n### Dispatching Commands\n\n```typescript\nimport { CommandBus } from '@stratix/core';\n\n// Dispatch command\nconst result = await commandBus.dispatch(\n  new CreateProductCommand('Laptop', 999.99, 10)\n);\n\nif (result.isSuccess) {\n  console.log('Product created:', result.value);\n} else {\n  console.error('Failed:', result.error.message);\n}\n```\n\n## Queries (Read Operations)\n\nQueries represent **requests for data**.\n\n### Characteristics\n\n- ✅ Descriptive names (GetProductById, ListOrders)\n- ✅ Contain filter/search criteria\n- ✅ Return `Result<T>` with data\n- ✅ Never modify state\n\n### Example\n\n```typescript\nimport { Query } from '@stratix/core';\n\nexport class GetProductByIdQuery implements Query<Product> {\n  constructor(public readonly productId: string) {}\n}\n\nexport class ListProductsQuery implements Query<Product[]> {\n  constructor(\n    public readonly page: number = 1,\n    public readonly limit: number = 10,\n    public readonly category?: string\n  ) {}\n}\n```\n\n### Query Handler\n\n```typescript\nimport { QueryHandler, Result, Success, Failure } from '@stratix/core';\n\nexport class GetProductByIdHandler \n  implements QueryHandler<GetProductByIdQuery, Product> {\n  \n  constructor(private productRepository: IProductRepository) {}\n\n  async handle(query: GetProductByIdQuery): Promise<Result<Product>> {\n    const product = await this.productRepository.findById(query.productId);\n\n    if (!product) {\n      return Failure.create(new Error('Product not found'));\n    }\n\n    return Success.create(product);\n  }\n}\n\nexport class ListProductsHandler \n  implements QueryHandler<ListProductsQuery, Product[]> {\n  \n  constructor(private productRepository: IProductRepository) {}\n\n  async handle(query: ListProductsQuery): Promise<Result<Product[]>> {\n    const products = await this.productRepository.findAll({\n      page: query.page,\n      limit: query.limit,\n      category: query.category\n    });\n\n    return Success.create(products);\n  }\n}\n```\n\n### Executing Queries\n\n```typescript\nimport { QueryBus } from '@stratix/core';\n\n// Execute query\nconst result = await queryBus.execute(\n  new GetProductByIdQuery('product-123')\n);\n\nif (result.isSuccess) {\n  console.log('Product:', result.value);\n}\n\n// List query\nconst listResult = await queryBus.execute(\n  new ListProductsQuery(1, 20, 'electronics')\n);\n```\n\n## Command Bus\n\nThe **Command Bus** dispatches commands to their handlers.\n\n### Setup\n\n```typescript\nimport { InMemoryCommandBus } from '@stratix/core';\n\nconst commandBus = new InMemoryCommandBus();\n\n// Register handlers\ncommandBus.register(\n  CreateProductCommand,\n  new CreateProductHandler(productRepository, eventBus)\n);\n\ncommandBus.register(\n  UpdateProductCommand,\n  new UpdateProductHandler(productRepository)\n);\n```\n\n### Usage\n\n```typescript\n// Dispatch command\nconst result = await commandBus.dispatch(\n  new CreateProductCommand('Laptop', 999.99, 10)\n);\n```\n\n## Query Bus\n\nThe **Query Bus** executes queries and returns results.\n\n### Setup\n\n```typescript\nimport { InMemoryQueryBus } from '@stratix/core';\n\nconst queryBus = new InMemoryQueryBus();\n\n// Register handlers\nqueryBus.register(\n  GetProductByIdQuery,\n  new GetProductByIdHandler(productRepository)\n);\n\nqueryBus.register(\n  ListProductsQuery,\n  new ListProductsHandler(productRepository)\n);\n```\n\n### Usage\n\n```typescript\n// Execute query\nconst result = await queryBus.execute(\n  new GetProductByIdQuery('product-123')\n);\n```\n\n## HTTP Integration\n\n### Commands in Controllers\n\n```typescript\nimport { FastifyHTTPPlugin, HttpErrorImpl } from '@stratix/http-fastify';\n\nhttpPlugin.post('/products', async (request) => {\n  const { name, price, stock } = request.body;\n\n  const result = await commandBus.dispatch(\n    new CreateProductCommand(name, price, stock)\n  );\n\n  if (result.isFailure) {\n    throw HttpErrorImpl.badRequest(result.error.message);\n  }\n\n  return { statusCode: 201, body: result.value };\n});\n\nhttpPlugin.put('/products/:id', async (request) => {\n  const { id } = request.params;\n  const { name, price } = request.body;\n\n  const result = await commandBus.dispatch(\n    new UpdateProductCommand(id, name, price)\n  );\n\n  if (result.isFailure) {\n    throw HttpErrorImpl.badRequest(result.error.message);\n  }\n\n  return { body: result.value };\n});\n```\n\n### Queries in Controllers\n\n```typescript\nhttpPlugin.get('/products/:id', async (request) => {\n  const { id } = request.params;\n\n  const result = await queryBus.execute(\n    new GetProductByIdQuery(id)\n  );\n\n  if (result.isFailure) {\n    throw HttpErrorImpl.notFound('Product not found');\n  }\n\n  return { body: result.value };\n});\n\nhttpPlugin.get('/products', async (request) => {\n  const { page, limit, category } = request.query;\n\n  const result = await queryBus.execute(\n    new ListProductsQuery(\n      parseInt(page || '1'),\n      parseInt(limit || '10'),\n      category\n    )\n  );\n\n  return { body: result.value };\n});\n```\n\n## Event Bus\n\nThe **Event Bus** publishes and subscribes to domain events.\n\n### Publishing Events\n\n```typescript\nimport { InMemoryEventBus } from '@stratix/core';\n\nconst eventBus = new InMemoryEventBus();\n\n// Publish event\nawait eventBus.publish(\n  new ProductCreatedEvent(product.id, product.name)\n);\n```\n\n### Subscribing to Events\n\n```typescript\n// Register event handler\neventBus.subscribe(\n  'ProductCreated',\n  new ProductCreatedHandler(emailService)\n);\n\n// Event handler\nexport class ProductCreatedHandler \n  implements EventHandler<ProductCreatedEvent> {\n  \n  constructor(private emailService: EmailService) {}\n\n  async handle(event: ProductCreatedEvent): Promise<void> {\n    await this.emailService.sendProductCreatedEmail(event.productId);\n  }\n}\n```\n\n## Advanced Patterns\n\n### Read Model Optimization\n\n```typescript\n// Separate read model for queries\nexport class ProductReadModel {\n  constructor(\n    public readonly id: string,\n    public readonly name: string,\n    public readonly price: number,\n    public readonly category: string,\n    public readonly inStock: boolean\n  ) {}\n}\n\nexport class ListProductsHandler \n  implements QueryHandler<ListProductsQuery, ProductReadModel[]> {\n  \n  constructor(private db: Database) {}\n\n  async handle(query: ListProductsQuery): Promise<Result<ProductReadModel[]>> {\n    // Optimized query for reads\n    const products = await this.db('products_read_model')\n      .select('*')\n      .where('category', query.category)\n      .limit(query.limit)\n      .offset((query.page - 1) * query.limit);\n\n    return Success.create(products);\n  }\n}\n```\n\n### Command Validation\n\n```typescript\nexport class CreateProductHandler {\n  async handle(command: CreateProductCommand): Promise<Result<Product>> {\n    // Validate command\n    const validation = this.validate(command);\n    if (validation.isFailure) {\n      return validation;\n    }\n\n    // Process command\n    // ...\n  }\n\n  private validate(command: CreateProductCommand): Result<void> {\n    if (!command.name || command.name.trim().length === 0) {\n      return Failure.create(new Error('Name is required'));\n    }\n\n    if (command.price <= 0) {\n      return Failure.create(new Error('Price must be positive'));\n    }\n\n    if (command.stock < 0) {\n      return Failure.create(new Error('Stock cannot be negative'));\n    }\n\n    return Success.create(undefined);\n  }\n}\n```\n\n## Best Practices\n\n### 1. Commands Should Be Imperative\n\n```typescript\n// ✅ Good: Imperative\nCreateProductCommand\nUpdateOrderCommand\nDeleteCustomerCommand\n\n// ❌ Bad: Not imperative\nProductCommand\nOrderCommand\n```\n\n### 2. Queries Should Be Descriptive\n\n```typescript\n// ✅ Good: Descriptive\nGetProductByIdQuery\nListActiveOrdersQuery\nFindCustomersByEmailQuery\n\n// ❌ Bad: Not descriptive\nProductQuery\nOrdersQuery\n```\n\n### 3. Never Modify State in Queries\n\n```typescript\n// ✅ Good: Read-only\nexport class GetProductHandler {\n  async handle(query: GetProductByIdQuery): Promise<Result<Product>> {\n    return await this.repository.findById(query.id);\n  }\n}\n\n// ❌ Bad: Modifying state\nexport class GetProductHandler {\n  async handle(query: GetProductByIdQuery): Promise<Result<Product>> {\n    const product = await this.repository.findById(query.id);\n    product.incrementViewCount(); // Don't modify in queries!\n    await this.repository.save(product);\n    return product;\n  }\n}\n```\n\n### 4. Use Result Pattern\n\n```typescript\n// ✅ Good: Returns Result\nasync handle(command: CreateProductCommand): Promise<Result<Product>> {\n  if (command.price <= 0) {\n    return Failure.create(new Error('Invalid price'));\n  }\n  return Success.create(product);\n}\n\n// ❌ Bad: Throws exceptions\nasync handle(command: CreateProductCommand): Promise<Product> {\n  if (command.price <= 0) {\n    throw new Error('Invalid price');\n  }\n  return product;\n}\n```\n\n## When to Use CQRS\n\n### Use CQRS When:\n\n- ✅ Different read and write performance requirements\n- ✅ Complex business logic on writes\n- ✅ Simple, optimized reads\n- ✅ Event-driven architecture\n- ✅ Scalability is important\n\n### Don't Use CQRS When:\n\n- ❌ Simple CRUD operations\n- ❌ Small applications\n- ❌ Reads and writes are similar\n- ❌ Team is unfamiliar with the pattern\n\n## Next Steps\n\n- **[Domain Modeling](./domain-modeling)** - Entities and value objects\n- **[Result Pattern](./result-pattern)** - Error handling\n- **[Bounded Contexts](./bounded-contexts)** - Modular architecture\n",
      "metadata": {
        "type": "docs",
        "category": "core-concepts",
        "source": "docs/core-concepts/cqrs.md",
        "title": "CQRS"
      }
    },
    {
      "id": "docs-core-concepts-dependency-injection",
      "content": "\n# Dependency Injection\n\nStratix uses **Dependency Injection** (DI) to manage dependencies and promote loose coupling, testability, and maintainability.\n\n## The Container Abstraction\n\nStratix provides a **Container** interface that abstracts the DI implementation:\n\n```typescript\nimport { Container } from '@stratix/core';\n\ninterface Container {\n  register<T>(\n    token: string,\n    factory: Factory<T>,\n    options?: RegisterOptions\n  ): void;\n  \n  resolve<T>(token: string): T;\n  \n  has(token: string): boolean;\n}\n```\n\nThis allows you to use any DI container (Awilix, TSyringe, InversifyJS, etc.) or even build your own.\n\n## Service Lifetimes\n\nStratix supports three service lifetimes:\n\n```typescript\nimport { ServiceLifetime } from '@stratix/core';\n\nenum ServiceLifetime {\n  SINGLETON = 'SINGLETON',     // One instance for the entire application\n  SCOPED = 'SCOPED',          // One instance per scope (e.g., per request)\n  TRANSIENT = 'TRANSIENT'     // New instance every time\n}\n```\n\n### Singleton\n\n**One instance** for the entire application lifecycle:\n\n```typescript\ncontainer.register(\n  'database',\n  () => new Database(config),\n  { lifetime: ServiceLifetime.SINGLETON }\n);\n\n// Same instance every time\nconst db1 = container.resolve('database');\nconst db2 = container.resolve('database');\nconsole.log(db1 === db2); // true\n```\n\n**Use for:**\n- ✅ Database connections\n- ✅ Configuration\n- ✅ Caches\n- ✅ Loggers\n\n### Scoped\n\n**One instance per scope** (e.g., per HTTP request):\n\n```typescript\ncontainer.register(\n  'unitOfWork',\n  () => new UnitOfWork(database),\n  { lifetime: ServiceLifetime.SCOPED }\n);\n\n// Same instance within a scope\nconst scope = container.createScope();\nconst uow1 = scope.resolve('unitOfWork');\nconst uow2 = scope.resolve('unitOfWork');\nconsole.log(uow1 === uow2); // true\n\n// Different instance in different scope\nconst scope2 = container.createScope();\nconst uow3 = scope2.resolve('unitOfWork');\nconsole.log(uow1 === uow3); // false\n```\n\n**Use for:**\n- ✅ Unit of Work\n- ✅ Request-scoped services\n- ✅ Transaction managers\n\n### Transient\n\n**New instance** every time:\n\n```typescript\ncontainer.register(\n  'emailService',\n  () => new EmailService(config),\n  { lifetime: ServiceLifetime.TRANSIENT }\n);\n\n// Different instance every time\nconst email1 = container.resolve('emailService');\nconst email2 = container.resolve('emailService');\nconsole.log(email1 === email2); // false\n```\n\n**Use for:**\n- ✅ Stateful services\n- ✅ Services with per-operation state\n- ✅ Lightweight objects\n\n## Using Awilix (Recommended)\n\nStratix recommends **Awilix** as the DI container:\n\n```bash\nnpm install @stratix/di-awilix\n```\n\n### Basic Setup\n\n```typescript\nimport { AwilixContainer } from '@stratix/di-awilix';\nimport { ServiceLifetime } from '@stratix/core';\n\nconst container = new AwilixContainer();\n\n// Register services\ncontainer.register(\n  'database',\n  () => new PostgresDatabase(config),\n  { lifetime: ServiceLifetime.SINGLETON }\n);\n\ncontainer.register(\n  'productRepository',\n  (c) => new PostgresProductRepository(c.resolve('database')),\n  { lifetime: ServiceLifetime.SINGLETON }\n);\n\ncontainer.register(\n  'createProductHandler',\n  (c) => new CreateProductHandler(\n    c.resolve('productRepository'),\n    c.resolve('eventBus')\n  ),\n  { lifetime: ServiceLifetime.TRANSIENT }\n);\n\n// Resolve services\nconst handler = container.resolve('createProductHandler');\n```\n\n## Registration Patterns\n\n### Constructor Injection\n\n```typescript\nexport class CreateProductHandler {\n  constructor(\n    private productRepository: IProductRepository,\n    private eventBus: EventBus\n  ) {}\n\n  async handle(command: CreateProductCommand): Promise<Result<Product>> {\n    // Use injected dependencies\n    const product = new Product(/* ... */);\n    await this.productRepository.save(product);\n    await this.eventBus.publish(new ProductCreatedEvent(product.id));\n    return Success.create(product);\n  }\n}\n\n// Register with dependencies\ncontainer.register(\n  'createProductHandler',\n  (c) => new CreateProductHandler(\n    c.resolve('productRepository'),\n    c.resolve('eventBus')\n  )\n);\n```\n\n### Factory Functions\n\n```typescript\n// Simple factory\ncontainer.register(\n  'logger',\n  () => new ConsoleLogger()\n);\n\n// Factory with configuration\ncontainer.register(\n  'database',\n  () => new Database({\n    host: process.env.DB_HOST,\n    port: parseInt(process.env.DB_PORT || '5432'),\n    database: process.env.DB_NAME\n  })\n);\n\n// Factory with dependencies\ncontainer.register(\n  'userService',\n  (c) => new UserService(\n    c.resolve('userRepository'),\n    c.resolve('emailService'),\n    c.resolve('logger')\n  )\n);\n```\n\n## Plugin Integration\n\nPlugins can register services in the container:\n\n```typescript\nimport { Plugin, PluginContext } from '@stratix/core';\n\nexport class PostgresPlugin implements Plugin {\n  readonly metadata = {\n    name: 'postgres',\n    version: '1.0.0'\n  };\n\n  async initialize(context: PluginContext): Promise<void> {\n    const config = context.getConfig<PostgresConfig>();\n    \n    // Register database connection\n    context.container.register(\n      'database',\n      () => new PostgresDatabase(config),\n      { lifetime: ServiceLifetime.SINGLETON }\n    );\n\n    // Register repositories\n    context.container.register(\n      'productRepository',\n      (c) => new PostgresProductRepository(c.resolve('database')),\n      { lifetime: ServiceLifetime.SINGLETON }\n    );\n  }\n}\n```\n\n## Application Setup\n\n### With ApplicationBuilder\n\n```typescript\nimport { ApplicationBuilder } from '@stratix/runtime';\nimport { AwilixContainer } from '@stratix/di-awilix';\n\nconst app = await ApplicationBuilder.create()\n  .useContainer(new AwilixContainer())\n  .useLogger(new ConsoleLogger())\n  \n  // Plugins register their services\n  .usePlugin(new PostgresPlugin({ /* config */ }))\n  .usePlugin(new FastifyHTTPPlugin({ port: 3000 }))\n  \n  .build();\n\n// Resolve services\nconst database = app.resolve('database');\nconst productRepository = app.resolve('productRepository');\n```\n\n### Manual Setup\n\n```typescript\nconst container = new AwilixContainer();\n\n// Register infrastructure\ncontainer.register('logger', () => new ConsoleLogger());\ncontainer.register('database', () => new PostgresDatabase(config));\n\n// Register repositories\ncontainer.register(\n  'productRepository',\n  (c) => new PostgresProductRepository(c.resolve('database'))\n);\n\n// Register command handlers\ncontainer.register(\n  'createProductHandler',\n  (c) => new CreateProductHandler(\n    c.resolve('productRepository'),\n    c.resolve('eventBus')\n  )\n);\n\n// Register command bus\nconst commandBus = new InMemoryCommandBus();\ncommandBus.register(\n  CreateProductCommand,\n  container.resolve('createProductHandler')\n);\n\ncontainer.register('commandBus', () => commandBus);\n```\n\n## Testing with DI\n\n### Mock Dependencies\n\n```typescript\ndescribe('CreateProductHandler', () => {\n  it('should create product', async () => {\n    // Create mock repository\n    const mockRepository: IProductRepository = {\n      save: jest.fn(),\n      findById: jest.fn(),\n      findAll: jest.fn()\n    };\n\n    // Create mock event bus\n    const mockEventBus: EventBus = {\n      publish: jest.fn(),\n      subscribe: jest.fn()\n    };\n\n    // Inject mocks\n    const handler = new CreateProductHandler(\n      mockRepository,\n      mockEventBus\n    );\n\n    // Test\n    const result = await handler.handle(\n      new CreateProductCommand('Laptop', 999.99, 10)\n    );\n\n    expect(result.isSuccess).toBe(true);\n    expect(mockRepository.save).toHaveBeenCalled();\n    expect(mockEventBus.publish).toHaveBeenCalled();\n  });\n});\n```\n\n### Test Container\n\n```typescript\ndescribe('Integration Tests', () => {\n  let container: Container;\n\n  beforeEach(() => {\n    container = new AwilixContainer();\n\n    // Register test dependencies\n    container.register('database', () => new InMemoryDatabase());\n    container.register(\n      'productRepository',\n      (c) => new InMemoryProductRepository()\n    );\n  });\n\n  it('should create product', async () => {\n    const handler = container.resolve('createProductHandler');\n    const result = await handler.handle(command);\n    expect(result.isSuccess).toBe(true);\n  });\n});\n```\n\n## Best Practices\n\n### 1. Depend on Abstractions\n\n```typescript\n// ✅ Good: Depends on interface\nexport class CreateProductHandler {\n  constructor(private repository: IProductRepository) {}\n}\n\n// ❌ Bad: Depends on concrete class\nexport class CreateProductHandler {\n  constructor(private repository: PostgresProductRepository) {}\n}\n```\n\n### 2. Use Constructor Injection\n\n```typescript\n// ✅ Good: Constructor injection\nexport class UserService {\n  constructor(\n    private userRepository: IUserRepository,\n    private emailService: EmailService\n  ) {}\n}\n\n// ❌ Bad: Property injection\nexport class UserService {\n  @Inject()\n  private userRepository!: IUserRepository;\n}\n```\n\n### 3. Register at Application Startup\n\n```typescript\n// ✅ Good: Register during startup\nconst app = await ApplicationBuilder.create()\n  .useContainer(container)\n  .usePlugin(new PostgresPlugin())\n  .build();\n\n// ❌ Bad: Register during request\napp.get('/products', async () => {\n  container.register('productRepository', ...); // Don't do this!\n});\n```\n\n### 4. Use Appropriate Lifetimes\n\n```typescript\n// ✅ Good: Singleton for stateless services\ncontainer.register('logger', () => new Logger(), {\n  lifetime: ServiceLifetime.SINGLETON\n});\n\n// ✅ Good: Transient for stateful services\ncontainer.register('emailBuilder', () => new EmailBuilder(), {\n  lifetime: ServiceLifetime.TRANSIENT\n});\n\n// ❌ Bad: Singleton for stateful service\ncontainer.register('requestContext', () => new RequestContext(), {\n  lifetime: ServiceLifetime.SINGLETON // Will share state!\n});\n```\n\n## Advanced Patterns\n\n### Conditional Registration\n\n```typescript\nif (process.env.NODE_ENV === 'production') {\n  container.register('logger', () => new ProductionLogger());\n} else {\n  container.register('logger', () => new ConsoleLogger());\n}\n```\n\n### Decorators\n\n```typescript\n// Base service\ncontainer.register('productRepository', () => new PostgresProductRepository());\n\n// Wrap with caching\nconst baseRepo = container.resolve('productRepository');\ncontainer.register(\n  'productRepository',\n  () => new CachedProductRepository(baseRepo, cache)\n);\n```\n\n### Factory Pattern\n\n```typescript\ncontainer.register(\n  'repositoryFactory',\n  (c) => ({\n    createProductRepository: () => c.resolve('productRepository'),\n    createOrderRepository: () => c.resolve('orderRepository')\n  })\n);\n```\n\n## Next Steps\n\n- **[Architecture Overview](./architecture-overview)** - Hexagonal architecture\n- **[Plugin System](../plugins/plugin-architecture)** - Plugin development\n- **[CQRS](./cqrs)** - Command and query handlers\n",
      "metadata": {
        "type": "docs",
        "category": "core-concepts",
        "source": "docs/core-concepts/dependency-injection.md",
        "title": "Dependency Injection"
      }
    },
    {
      "id": "docs-core-concepts-domain-modeling",
      "content": "\n# Domain Modeling\n\nDomain modeling is the heart of Domain-Driven Design. Stratix provides powerful primitives to model your business domain accurately.\n\n## Core Building Blocks\n\n```mermaid\ngraph TB\n    Entity[Entity<br/>Has Identity]\n    AggregateRoot[Aggregate Root<br/>Entity + Events]\n    ValueObject[Value Object<br/>Immutable]\n    DomainService[Domain Service<br/>Stateless Logic]\n    \n    AggregateRoot -.->|extends| Entity\n    Entity -.->|uses| ValueObject\n    DomainService -.->|operates on| Entity\n    DomainService -.->|operates on| ValueObject\n```\n\n## Entity\n\nAn **Entity** is an object with a unique identity that persists over time.\n\n### Characteristics\n\n- ✅ Has a unique identifier\n- ✅ Mutable (can change over time)\n- ✅ Identity-based equality\n- ✅ Has lifecycle (created, updated, deleted)\n\n### Example\n\n```typescript\nimport { Entity, EntityId } from '@stratix/core';\n\ntype UserId = EntityId<'User'>;\n\nexport class User extends Entity<'User'> {\n  constructor(\n    id: UserId,\n    private email: string,\n    private name: string,\n    private isActive: boolean,\n    createdAt: Date,\n    updatedAt: Date\n  ) {\n    super(id, createdAt, updatedAt);\n  }\n\n  // Getters\n  get Email(): string {\n    return this.email;\n  }\n\n  get Name(): string {\n    return this.name;\n  }\n\n  get IsActive(): boolean {\n    return this.isActive;\n  }\n\n  // Business methods\n  changeName(newName: string): void {\n    if (!newName || newName.trim().length === 0) {\n      throw new Error('Name cannot be empty');\n    }\n    this.name = newName;\n    this.touch(); // Updates updatedAt timestamp\n  }\n\n  deactivate(): void {\n    if (!this.isActive) {\n      throw new Error('User is already inactive');\n    }\n    this.isActive = false;\n    this.touch();\n  }\n\n  activate(): void {\n    if (this.isActive) {\n      throw new Error('User is already active');\n    }\n    this.isActive = true;\n    this.touch();\n  }\n}\n\n// Usage\nconst userId = EntityId.create<'User'>();\nconst user = new User(\n  userId,\n  'john@example.com',\n  'John Doe',\n  true,\n  new Date(),\n  new Date()\n);\n\nuser.changeName('John Smith');\nconsole.log(user.Name); // \"John Smith\"\n```\n\n### Entity Equality\n\nEntities are equal if they have the same ID:\n\n```typescript\nconst user1 = new User(userId, 'john@example.com', 'John', true, now, now);\nconst user2 = new User(userId, 'jane@example.com', 'Jane', false, now, now);\n\nconsole.log(user1.equals(user2)); // true (same ID)\n```\n\n## Aggregate Root\n\nAn **Aggregate Root** is an entity that serves as the entry point to an aggregate - a cluster of related objects treated as a single unit.\n\n### Characteristics\n\n- ✅ All characteristics of Entity\n- ✅ Can emit domain events\n- ✅ Enforces invariants across the aggregate\n- ✅ Controls access to child entities\n\n### Example\n\n```typescript\nimport { AggregateRoot, EntityId } from '@stratix/core';\n\ntype OrderId = EntityId<'Order'>;\n\nexport class Order extends AggregateRoot<'Order'> {\n  private items: OrderItem[] = [];\n  private status: OrderStatus = OrderStatus.PENDING;\n\n  constructor(\n    id: OrderId,\n    private customerId: string,\n    createdAt: Date,\n    updatedAt: Date\n  ) {\n    super(id, createdAt, updatedAt);\n  }\n\n  // Add item to order\n  addItem(productId: string, quantity: number, price: Money): void {\n    // Enforce invariant: can only add items to pending orders\n    if (this.status !== OrderStatus.PENDING) {\n      throw new Error('Cannot add items to non-pending order');\n    }\n\n    const item = new OrderItem(productId, quantity, price);\n    this.items.push(item);\n\n    // Emit domain event\n    this.addDomainEvent(new OrderItemAddedEvent(this.id, productId, quantity));\n    this.touch();\n  }\n\n  // Remove item from order\n  removeItem(productId: string): void {\n    if (this.status !== OrderStatus.PENDING) {\n      throw new Error('Cannot remove items from non-pending order');\n    }\n\n    const index = this.items.findIndex(item => item.productId === productId);\n    if (index === -1) {\n      throw new Error('Item not found in order');\n    }\n\n    this.items.splice(index, 1);\n    this.addDomainEvent(new OrderItemRemovedEvent(this.id, productId));\n    this.touch();\n  }\n\n  // Confirm order\n  confirm(): void {\n    // Enforce invariant: order must have items\n    if (this.items.length === 0) {\n      throw new Error('Cannot confirm empty order');\n    }\n\n    // Enforce invariant: order must be pending\n    if (this.status !== OrderStatus.PENDING) {\n      throw new Error('Only pending orders can be confirmed');\n    }\n\n    this.status = OrderStatus.CONFIRMED;\n    this.addDomainEvent(new OrderConfirmedEvent(this.id, this.calculateTotal()));\n    this.touch();\n  }\n\n  // Calculate total\n  calculateTotal(): Money {\n    return this.items.reduce(\n      (total, item) => total.add(item.price.multiply(item.quantity)),\n      Money.USD(0)\n    );\n  }\n\n  // Getters\n  get Items(): readonly OrderItem[] {\n    return this.items; // Return readonly to prevent external modification\n  }\n\n  get Status(): OrderStatus {\n    return this.status;\n  }\n\n  get CustomerId(): string {\n    return this.customerId;\n  }\n}\n\n// Child entity (not an aggregate root)\nclass OrderItem {\n  constructor(\n    public readonly productId: string,\n    public readonly quantity: number,\n    public readonly price: Money\n  ) {}\n}\n\nenum OrderStatus {\n  PENDING = 'PENDING',\n  CONFIRMED = 'CONFIRMED',\n  SHIPPED = 'SHIPPED',\n  DELIVERED = 'DELIVERED',\n  CANCELLED = 'CANCELLED'\n}\n```\n\n### Domain Events\n\n```typescript\n// Retrieve and clear domain events\nconst events = order.getDomainEvents();\norder.clearDomainEvents();\n\n// Publish events\nfor (const event of events) {\n  await eventBus.publish(event);\n}\n```\n\n## Value Object\n\nA **Value Object** is an immutable object defined by its attributes, not its identity.\n\n### Characteristics\n\n- ✅ Immutable (cannot change after creation)\n- ✅ Value-based equality\n- ✅ No identity\n- ✅ Self-validating\n\n### Example\n\n```typescript\nimport { ValueObject, Result, Success, Failure } from '@stratix/core';\n\ninterface EmailProps {\n  value: string;\n}\n\nexport class Email extends ValueObject<EmailProps> {\n  private constructor(props: EmailProps) {\n    super(props);\n  }\n\n  static create(email: string): Result<Email> {\n    // Validation\n    if (!email || email.trim().length === 0) {\n      return Failure.create(new Error('Email cannot be empty'));\n    }\n\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n      return Failure.create(new Error('Invalid email format'));\n    }\n\n    return Success.create(new Email({ value: email.toLowerCase() }));\n  }\n\n  get value(): string {\n    return this.props.value;\n  }\n\n  get domain(): string {\n    return this.props.value.split('@')[1];\n  }\n}\n\n// Usage\nconst emailResult = Email.create('john@example.com');\n\nif (emailResult.isSuccess) {\n  const email = emailResult.value;\n  console.log(email.value);  // \"john@example.com\"\n  console.log(email.domain); // \"example.com\"\n}\n```\n\n### Built-in Value Objects\n\nStratix provides 11 built-in value objects:\n\n```typescript\nimport {\n  Money,\n  Currency,\n  Email,\n  URL,\n  PhoneNumber,\n  UUID,\n  DateRange,\n  Percentage,\n  Address\n} from '@stratix/core';\n\n// Money\nconst price = Money.USD(99.99);\nconst discounted = price.multiply(0.8);\nconsole.log(discounted.format()); // \"$79.99\"\n\n// Email\nconst email = Email.create('user@example.com');\n\n// Phone Number\nconst phoneResult = PhoneNumber.create('+14155552671');\nif (phoneResult.isSuccess) {\n  console.log(phoneResult.value.format()); // \"+1 (415) 555-2671\"\n}\n\n// Date Range\nconst rangeResult = DateRange.create(\n  new Date('2024-01-01'),\n  new Date('2024-12-31')\n);\n\n// Percentage\nconst discount = Percentage.fromPercentage(15); // 15%\n\n// Address\nconst addressResult = Address.create({\n  street: '123 Main St',\n  city: 'San Francisco',\n  state: 'CA',\n  postalCode: '94102',\n  country: 'US'\n});\n```\n\n### Value Object Equality\n\nValue objects are equal if their values are equal:\n\n```typescript\nconst email1 = Email.create('john@example.com').value;\nconst email2 = Email.create('john@example.com').value;\n\nconsole.log(email1.equals(email2)); // true (same value)\n```\n\n## Domain Service\n\nA **Domain Service** contains business logic that doesn't naturally fit within an entity or value object.\n\n### When to Use\n\nUse a Domain Service when:\n- ✅ Logic involves multiple entities\n- ✅ Logic doesn't belong to any single entity\n- ✅ Operation is stateless\n\n### Example\n\n```typescript\nimport { DomainService } from '@stratix/core';\n\nexport class PricingService extends DomainService {\n  calculateOrderDiscount(order: Order, customer: Customer): Money {\n    let discount = Money.USD(0);\n\n    // VIP customers get 10% discount\n    if (customer.isVIP) {\n      const total = order.calculateTotal();\n      discount = total.multiply(0.1);\n    }\n\n    // Orders over $100 get additional $10 off\n    if (order.calculateTotal().amount > 100) {\n      discount = discount.add(Money.USD(10));\n    }\n\n    return discount;\n  }\n\n  calculateShippingCost(order: Order, address: Address): Money {\n    const total = order.calculateTotal();\n    \n    // Free shipping over $50\n    if (total.amount >= 50) {\n      return Money.USD(0);\n    }\n\n    // International shipping\n    if (address.country !== 'US') {\n      return Money.USD(25);\n    }\n\n    // Domestic shipping\n    return Money.USD(5);\n  }\n}\n\n// Usage\nconst pricingService = new PricingService();\nconst discount = pricingService.calculateOrderDiscount(order, customer);\nconst shipping = pricingService.calculateShippingCost(order, address);\n```\n\n## Repository Pattern\n\nRepositories provide an abstraction for data access:\n\n```typescript\n// Domain layer - Interface\nexport interface IProductRepository {\n  save(product: Product): Promise<void>;\n  findById(id: EntityId<'Product'>): Promise<Product | null>;\n  findAll(): Promise<Product[]>;\n  delete(id: EntityId<'Product'>): Promise<void>;\n}\n\n// Infrastructure layer - Implementation\nexport class PostgresProductRepository implements IProductRepository {\n  constructor(private db: Database) {}\n\n  async save(product: Product): Promise<void> {\n    await this.db('products')\n      .insert(this.toPersistence(product))\n      .onConflict('id')\n      .merge();\n  }\n\n  async findById(id: EntityId<'Product'>): Promise<Product | null> {\n    const row = await this.db('products').where({ id }).first();\n    return row ? this.toDomain(row) : null;\n  }\n\n  private toDomain(row: any): Product {\n    return new Product(\n      row.id,\n      row.name,\n      Money.USD(row.price),\n      row.created_at,\n      row.updated_at\n    );\n  }\n\n  private toPersistence(product: Product): any {\n    return {\n      id: product.id,\n      name: product.name,\n      price: product.price.amount,\n      created_at: product.createdAt,\n      updated_at: product.updatedAt\n    };\n  }\n}\n```\n\n## Best Practices\n\n### 1. Keep Entities Focused\n\n```typescript\n// ✅ Good: Focused entity\nexport class Product {\n  updatePrice(newPrice: Money): void {\n    this.price = newPrice;\n  }\n}\n\n// ❌ Bad: Entity doing too much\nexport class Product {\n  async saveToDatabase(): Promise<void> { /* ... */ }\n  async sendEmailNotification(): Promise<void> { /* ... */ }\n}\n```\n\n### 2. Make Value Objects Immutable\n\n```typescript\n// ✅ Good: Immutable\nexport class Money {\n  add(other: Money): Money {\n    return new Money(this.amount + other.amount, this.currency);\n  }\n}\n\n// ❌ Bad: Mutable\nexport class Money {\n  add(other: Money): void {\n    this.amount += other.amount; // Mutates!\n  }\n}\n```\n\n### 3. Validate in Constructors\n\n```typescript\n// ✅ Good: Validation in factory method\nexport class Email {\n  static create(value: string): Result<Email> {\n    if (!this.isValid(value)) {\n      return Failure.create(new Error('Invalid email'));\n    }\n    return Success.create(new Email({ value }));\n  }\n}\n\n// ❌ Bad: No validation\nexport class Email {\n  constructor(public value: string) {}\n}\n```\n\n### 4. Use Aggregate Roots for Consistency\n\n```typescript\n// ✅ Good: Modify through aggregate root\norder.addItem(productId, quantity, price);\n\n// ❌ Bad: Direct modification of child entity\norder.items.push(new OrderItem(/* ... */));\n```\n\n## Next Steps\n\n- **[Result Pattern](./result-pattern)** - Type-safe error handling\n- **[CQRS](./cqrs)** - Commands and queries\n- **[Architecture Overview](./architecture-overview)** - Hexagonal architecture\n",
      "metadata": {
        "type": "docs",
        "category": "core-concepts",
        "source": "docs/core-concepts/domain-modeling.md",
        "title": "Domain Modeling"
      }
    },
    {
      "id": "docs-core-concepts-result-pattern",
      "content": "\n# Result Pattern\n\nThe **Result Pattern** provides explicit, type-safe error handling without throwing exceptions.\n\n## The Problem with Exceptions\n\n```typescript\n// ❌ Traditional approach with exceptions\nfunction divide(a: number, b: number): number {\n  if (b === 0) {\n    throw new Error('Division by zero'); // Hidden control flow\n  }\n  return a / b;\n}\n\ntry {\n  const result = divide(10, 0);\n  console.log(result);\n} catch (error) {\n  console.error(error); // Must remember to catch\n}\n```\n\n**Problems:**\n- ❌ Hidden control flow\n- ❌ Easy to forget error handling\n- ❌ No type safety for errors\n- ❌ Performance overhead\n\n## The Solution: Result Pattern\n\n```typescript\n// ✅ Result Pattern approach\nimport { Result, Success, Failure } from '@stratix/core';\n\nfunction divide(a: number, b: number): Result<number> {\n  if (b === 0) {\n    return Failure.create(new Error('Division by zero'));\n  }\n  return Success.create(a / b);\n}\n\nconst result = divide(10, 2);\n\nif (result.isSuccess) {\n  console.log(result.value); // 5\n} else {\n  console.error(result.error.message);\n}\n```\n\n**Benefits:**\n- ✅ Explicit error handling\n- ✅ Type-safe\n- ✅ Compiler enforces checking\n- ✅ No hidden control flow\n\n## Basic Usage\n\n### Creating Success Results\n\n```typescript\nimport { Success } from '@stratix/core';\n\nconst result = Success.create(42);\n\nconsole.log(result.isSuccess); // true\nconsole.log(result.isFailure); // false\nconsole.log(result.value);     // 42\n```\n\n### Creating Failure Results\n\n```typescript\nimport { Failure } from '@stratix/core';\n\nconst result = Failure.create(new Error('Something went wrong'));\n\nconsole.log(result.isSuccess); // false\nconsole.log(result.isFailure); // true\nconsole.log(result.error);     // Error: Something went wrong\n```\n\n### Checking Results\n\n```typescript\nconst result = divide(10, 2);\n\n// Type guard\nif (result.isSuccess) {\n  // TypeScript knows result.value exists\n  console.log(result.value);\n} else {\n  // TypeScript knows result.error exists\n  console.error(result.error.message);\n}\n```\n\n## Real-World Examples\n\n### Value Object Creation\n\n```typescript\nimport { ValueObject, Result, Success, Failure } from '@stratix/core';\n\nexport class Email extends ValueObject<{ value: string }> {\n  private constructor(props: { value: string }) {\n    super(props);\n  }\n\n  static create(email: string): Result<Email> {\n    // Validation\n    if (!email || email.trim().length === 0) {\n      return Failure.create(new Error('Email cannot be empty'));\n    }\n\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n      return Failure.create(new Error('Invalid email format'));\n    }\n\n    return Success.create(new Email({ value: email.toLowerCase() }));\n  }\n\n  get value(): string {\n    return this.props.value;\n  }\n}\n\n// Usage\nconst emailResult = Email.create('john@example.com');\n\nif (emailResult.isSuccess) {\n  const email = emailResult.value;\n  console.log(email.value); // \"john@example.com\"\n} else {\n  console.error(emailResult.error.message);\n}\n```\n\n### Command Handlers\n\n```typescript\nimport { CommandHandler, Result, Success, Failure } from '@stratix/core';\n\nexport class CreateUserHandler \n  implements CommandHandler<CreateUserCommand, User> {\n  \n  constructor(\n    private userRepository: IUserRepository,\n    private emailService: EmailService\n  ) {}\n\n  async handle(command: CreateUserCommand): Promise<Result<User>> {\n    // Validate email\n    const emailResult = Email.create(command.email);\n    if (emailResult.isFailure) {\n      return Failure.create(emailResult.error);\n    }\n\n    // Check if user exists\n    const existingUser = await this.userRepository.findByEmail(emailResult.value);\n    if (existingUser) {\n      return Failure.create(new Error('User already exists'));\n    }\n\n    // Create user\n    const user = new User(\n      EntityId.create<'User'>(),\n      emailResult.value,\n      command.name,\n      new Date(),\n      new Date()\n    );\n\n    // Save user\n    await this.userRepository.save(user);\n\n    // Send welcome email\n    const emailSent = await this.emailService.sendWelcomeEmail(user.email);\n    if (emailSent.isFailure) {\n      // Log error but don't fail the command\n      console.error('Failed to send welcome email:', emailSent.error);\n    }\n\n    return Success.create(user);\n  }\n}\n```\n\n### Query Handlers\n\n```typescript\nexport class GetUserByIdHandler \n  implements QueryHandler<GetUserByIdQuery, User> {\n  \n  constructor(private userRepository: IUserRepository) {}\n\n  async handle(query: GetUserByIdQuery): Promise<Result<User>> {\n    const user = await this.userRepository.findById(query.userId);\n\n    if (!user) {\n      return Failure.create(new Error('User not found'));\n    }\n\n    return Success.create(user);\n  }\n}\n```\n\n## HTTP Integration\n\n### Controller Example\n\n```typescript\nimport { FastifyHTTPPlugin, HttpErrorImpl } from '@stratix/http-fastify';\n\nhttpPlugin.post('/users', async (request) => {\n  const { email, name } = request.body;\n\n  const result = await commandBus.dispatch(\n    new CreateUserCommand(email, name)\n  );\n\n  if (result.isFailure) {\n    throw HttpErrorImpl.badRequest(result.error.message);\n  }\n\n  return { statusCode: 201, body: result.value };\n});\n\nhttpPlugin.get('/users/:id', async (request) => {\n  const { id } = request.params;\n\n  const result = await queryBus.execute(\n    new GetUserByIdQuery(id)\n  );\n\n  if (result.isFailure) {\n    throw HttpErrorImpl.notFound(result.error.message);\n  }\n\n  return { body: result.value };\n});\n```\n\n## Chaining Results\n\n### Map\n\nTransform a successful result:\n\n```typescript\nconst result = Success.create(5);\n\nconst doubled = result.map(value => value * 2);\n\nconsole.log(doubled.value); // 10\n```\n\n### FlatMap (Bind)\n\nChain operations that return Results:\n\n```typescript\nfunction parseNumber(str: string): Result<number> {\n  const num = parseInt(str);\n  if (isNaN(num)) {\n    return Failure.create(new Error('Invalid number'));\n  }\n  return Success.create(num);\n}\n\nfunction divide(a: number, b: number): Result<number> {\n  if (b === 0) {\n    return Failure.create(new Error('Division by zero'));\n  }\n  return Success.create(a / b);\n}\n\n// Chain operations\nconst result = parseNumber('10')\n  .flatMap(num => divide(num, 2));\n\nif (result.isSuccess) {\n  console.log(result.value); // 5\n}\n```\n\n## ResultUtils\n\nUtility functions for working with multiple Results:\n\n### Combine\n\nCombine multiple Results into one:\n\n```typescript\nimport { ResultUtils } from '@stratix/core';\n\nconst emailResult = Email.create('john@example.com');\nconst ageResult = Age.create(25);\nconst nameResult = Name.create('John Doe');\n\nconst combined = ResultUtils.combine([emailResult, ageResult, nameResult]);\n\nif (combined.isSuccess) {\n  const [email, age, name] = combined.value;\n  // All validations passed\n} else {\n  // At least one validation failed\n  console.error(combined.error);\n}\n```\n\n## Custom Error Types\n\n### Domain Errors\n\n```typescript\nimport { DomainError } from '@stratix/core';\n\nexport class UserNotFoundError extends DomainError {\n  constructor(userId: string) {\n    super(`User with ID ${userId} not found`);\n    this.name = 'UserNotFoundError';\n  }\n}\n\nexport class InvalidEmailError extends DomainError {\n  constructor(email: string) {\n    super(`Invalid email: ${email}`);\n    this.name = 'InvalidEmailError';\n  }\n}\n\n// Usage\nconst result = await userRepository.findById(userId);\n\nif (!result) {\n  return Failure.create(new UserNotFoundError(userId));\n}\n```\n\n### Error Handling by Type\n\n```typescript\nconst result = await commandBus.dispatch(command);\n\nif (result.isFailure) {\n  if (result.error instanceof UserNotFoundError) {\n    throw HttpErrorImpl.notFound(result.error.message);\n  } else if (result.error instanceof InvalidEmailError) {\n    throw HttpErrorImpl.badRequest(result.error.message);\n  } else {\n    throw HttpErrorImpl.internalServerError(result.error.message);\n  }\n}\n```\n\n## Best Practices\n\n### 1. Always Return Result from Domain Operations\n\n```typescript\n// ✅ Good: Returns Result\nstatic create(email: string): Result<Email> {\n  if (!this.isValid(email)) {\n    return Failure.create(new Error('Invalid email'));\n  }\n  return Success.create(new Email({ value: email }));\n}\n\n// ❌ Bad: Throws exception\nstatic create(email: string): Email {\n  if (!this.isValid(email)) {\n    throw new Error('Invalid email');\n  }\n  return new Email({ value: email });\n}\n```\n\n### 2. Check Results Before Using Values\n\n```typescript\n// ✅ Good: Checks result\nconst result = Email.create(input);\nif (result.isSuccess) {\n  console.log(result.value);\n}\n\n// ❌ Bad: Assumes success\nconst result = Email.create(input);\nconsole.log(result.value); // May not exist!\n```\n\n### 3. Propagate Failures\n\n```typescript\n// ✅ Good: Propagates failure\nasync handle(command: CreateUserCommand): Promise<Result<User>> {\n  const emailResult = Email.create(command.email);\n  if (emailResult.isFailure) {\n    return Failure.create(emailResult.error);\n  }\n  \n  // Continue with emailResult.value\n}\n\n// ❌ Bad: Swallows error\nasync handle(command: CreateUserCommand): Promise<Result<User>> {\n  const emailResult = Email.create(command.email);\n  if (emailResult.isFailure) {\n    console.error(emailResult.error); // Just logs\n  }\n  \n  // Continues anyway!\n}\n```\n\n### 4. Use Specific Error Types\n\n```typescript\n// ✅ Good: Specific error\nreturn Failure.create(new UserNotFoundError(userId));\n\n// ❌ Bad: Generic error\nreturn Failure.create(new Error('Error'));\n```\n\n## Comparison with Exceptions\n\n| Feature | Result Pattern | Exceptions |\n|---------|---------------|------------|\n| **Explicit** | ✅ Visible in signature | ❌ Hidden |\n| **Type Safety** | ✅ Compile-time checks | ❌ Runtime only |\n| **Performance** | ✅ No stack unwinding | ❌ Expensive |\n| **Control Flow** | ✅ Explicit | ❌ Hidden |\n| **Forced Handling** | ✅ Compiler enforces | ❌ Easy to forget |\n\n## When to Use Exceptions\n\nUse exceptions for:\n- ❌ Truly exceptional situations (system failures)\n- ❌ Framework/library boundaries\n- ❌ Unrecoverable errors\n\nUse Result Pattern for:\n- ✅ Business logic errors\n- ✅ Validation errors\n- ✅ Expected failures\n- ✅ Domain operations\n\n## Next Steps\n\n- **[Domain Modeling](./domain-modeling)** - Entities and value objects\n- **[CQRS](./cqrs)** - Commands and queries with Result\n- **[Architecture Overview](./architecture-overview)** - Hexagonal architecture\n",
      "metadata": {
        "type": "docs",
        "category": "core-concepts",
        "source": "docs/core-concepts/result-pattern.md",
        "title": "Result Pattern"
      }
    },
    {
      "id": "docs-database-database-overview",
      "content": "\n# Database Overview\n\nStratix supports multiple databases through plugins.\n\n## Available Database Plugins\n\n- **@stratix/postgres** - PostgreSQL\n- **@stratix/mongodb** - MongoDB\n- **@stratix/redis** - Redis\n\n## Repository Pattern\n\nStratix uses the Repository pattern for data access:\n\n```typescript\nexport interface IProductRepository {\n  save(product: Product): Promise<void>;\n  findById(id: string): Promise<Product | null>;\n  findAll(): Promise<Product[]>;\n  delete(id: string): Promise<void>;\n}\n```\n\n## PostgreSQL Example\n\n```typescript\nimport { PostgresPlugin } from '@stratix/postgres';\n\nconst app = await ApplicationBuilder.create()\n  .usePlugin(new PostgresPlugin({\n    host: 'localhost',\n    port: 5432,\n    database: 'myapp',\n    user: 'postgres',\n    password: 'password'\n  }))\n  .build();\n```\n\n## Repository Implementation\n\n```typescript\nexport class PostgresProductRepository implements IProductRepository {\n  constructor(private db: Database) {}\n\n  async save(product: Product): Promise<void> {\n    await this.db('products').insert({\n      id: product.id.toString(),\n      name: product.name,\n      price: product.price,\n      created_at: product.createdAt,\n      updated_at: product.updatedAt\n    });\n  }\n\n  async findById(id: string): Promise<Product | null> {\n    const row = await this.db('products')\n      .where({ id })\n      .first();\n\n    if (!row) return null;\n\n    return Product.create({\n      name: row.name,\n      price: row.price\n    });\n  }\n\n  async findAll(): Promise<Product[]> {\n    const rows = await this.db('products').select('*');\n    return rows.map(row => Product.create({\n      name: row.name,\n      price: row.price\n    }));\n  }\n\n  async delete(id: string): Promise<void> {\n    await this.db('products').where({ id }).delete();\n  }\n}\n```\n\n## Transactions\n\n```typescript\nasync createOrder(order: Order): Promise<void> {\n  await this.db.transaction(async (trx) => {\n    // Save order\n    await trx('orders').insert({\n      id: order.id.toString(),\n      total: order.total\n    });\n\n    // Save order items\n    for (const item of order.items) {\n      await trx('order_items').insert({\n        order_id: order.id.toString(),\n        product_id: item.productId,\n        quantity: item.quantity\n      });\n    }\n  });\n}\n```\n\n## Next Steps\n\n- **[PostgreSQL](./postgres)** - PostgreSQL integration\n- **[MongoDB](./mongodb)** - MongoDB integration\n",
      "metadata": {
        "type": "docs",
        "category": "database",
        "source": "docs/database/database-overview.md",
        "title": "Database Overview"
      }
    },
    {
      "id": "docs-database-mongodb",
      "content": "\n# MongoDB\n\nMongoDB integration for Stratix.\n\n## Installation\n\n```bash\nstratix add @stratix/mongodb\n```\n\n## Configuration\n\n```typescript\nimport { MongoDBPlugin } from '@stratix/mongodb';\n\nconst app = await ApplicationBuilder.create()\n  .usePlugin(new MongoDBPlugin({\n    url: process.env.MONGODB_URL!,\n    database: 'myapp'\n  }))\n  .build();\n```\n\n## Repository Implementation\n\n```typescript\nexport class MongoProductRepository implements IProductRepository {\n  constructor(private db: Db) {}\n\n  async save(product: Product): Promise<void> {\n    await this.db.collection('products').updateOne(\n      { _id: product.id.toString() },\n      {\n        $set: {\n          name: product.name,\n          price: product.price,\n          updatedAt: new Date()\n        }\n      },\n      { upsert: true }\n    );\n  }\n\n  async findById(id: string): Promise<Product | null> {\n    const doc = await this.db.collection('products')\n      .findOne({ _id: id });\n\n    return doc ? this.toDomain(doc) : null;\n  }\n\n  private toDomain(doc: any): Product {\n    return Product.create({\n      name: doc.name,\n      price: doc.price\n    });\n  }\n}\n```\n\n## Next Steps\n\n- **[Database Overview](./database-overview)** - Database basics\n- **[PostgreSQL](./postgres)** - PostgreSQL integration\n",
      "metadata": {
        "type": "docs",
        "category": "database",
        "source": "docs/database/mongodb.md",
        "title": "MongoDB"
      }
    },
    {
      "id": "docs-database-postgres",
      "content": "\n# PostgreSQL\n\nPostgreSQL database integration for Stratix.\n\n## Installation\n\n```bash\nstratix add @stratix/postgres\n```\n\n## Configuration\n\n```typescript\nimport { PostgresPlugin } from '@stratix/postgres';\n\nconst app = await ApplicationBuilder.create()\n  .usePlugin(new PostgresPlugin({\n    host: process.env.DB_HOST || 'localhost',\n    port: parseInt(process.env.DB_PORT || '5432'),\n    database: process.env.DB_NAME!,\n    user: process.env.DB_USER!,\n    password: process.env.DB_PASSWORD!,\n    pool: {\n      min: 2,\n      max: 10\n    },\n    ssl: process.env.NODE_ENV === 'production'\n  }))\n  .build();\n```\n\n## Repository Implementation\n\n```typescript\nexport class PostgresProductRepository implements IProductRepository {\n  constructor(private db: Database) {}\n\n  async save(product: Product): Promise<void> {\n    await this.db('products')\n      .insert({\n        id: product.id.toString(),\n        name: product.name,\n        price: product.price\n      })\n      .onConflict('id')\n      .merge();\n  }\n\n  async findById(id: string): Promise<Product | null> {\n    const row = await this.db('products')\n      .where({ id })\n      .first();\n\n    return row ? this.toDomain(row) : null;\n  }\n\n  private toDomain(row: any): Product {\n    return Product.create({\n      name: row.name,\n      price: row.price\n    });\n  }\n}\n```\n\n## Next Steps\n\n- **[Database Overview](./database-overview)** - Database basics\n",
      "metadata": {
        "type": "docs",
        "category": "database",
        "source": "docs/database/postgres.md",
        "title": "PostgreSQL"
      }
    },
    {
      "id": "docs-database-redis",
      "content": "\n# Redis\n\nRedis integration for caching and pub/sub.\n\n## Installation\n\n```bash\nstratix add @stratix/redis\n```\n\n## Configuration\n\n```typescript\nimport { RedisPlugin } from '@stratix/redis';\n\nconst app = await ApplicationBuilder.create()\n  .usePlugin(new RedisPlugin({\n    host: 'localhost',\n    port: 6379\n  }))\n  .build();\n```\n\n## Caching\n\n```typescript\nexport class CachedProductRepository implements IProductRepository {\n  constructor(\n    private repository: IProductRepository,\n    private redis: Redis\n  ) {}\n\n  async findById(id: string): Promise<Product | null> {\n    // Check cache\n    const cached = await this.redis.get(`product:${id}`);\n    if (cached) {\n      return JSON.parse(cached);\n    }\n\n    // Fetch from database\n    const product = await this.repository.findById(id);\n    \n    // Cache result\n    if (product) {\n      await this.redis.setex(\n        `product:${id}`,\n        3600,\n        JSON.stringify(product)\n      );\n    }\n\n    return product;\n  }\n}\n```\n\n## Pub/Sub\n\n```typescript\n// Publisher\nawait redis.publish('product.created', JSON.stringify({\n  id: product.id,\n  name: product.name\n}));\n\n// Subscriber\nredis.subscribe('product.created', (message) => {\n  const event = JSON.parse(message);\n  console.log('Product created:', event);\n});\n```\n\n## Next Steps\n\n- **[Database Overview](./database-overview)** - Database basics\n- **[PostgreSQL](./postgres)** - PostgreSQL integration\n",
      "metadata": {
        "type": "docs",
        "category": "database",
        "source": "docs/database/redis.md",
        "title": "Redis"
      }
    },
    {
      "id": "docs-getting-started-installation",
      "content": "\n# Installation\n\nThis guide will help you install Stratix and create your first project.\n\n## Prerequisites\n\nBefore you begin, ensure you have the following installed:\n\n- **Node.js** >= 18.0.0\n- **npm**, **pnpm**, or **yarn** package manager\n\n```bash\n# Check your Node.js version\nnode --version\n\n# Should output v18.0.0 or higher\n```\n\n## Install the CLI\n\nStratix provides a global CLI tool for creating projects and generating code.\n\n### Using npm\n\n```bash\nnpm install -g @stratix/cli\n```\n\n### Using pnpm\n\n```bash\npnpm add -g @stratix/cli\n```\n\n### Using yarn\n\n```bash\nyarn global add @stratix/cli\n```\n\n### Verify Installation\n\n```bash\nstratix --version\n\n# Should output: @stratix/cli/0.3.0 (or later)\n```\n\n## Create Your First Project\n\n### Interactive Mode (Recommended)\n\nThe easiest way to create a new project is using interactive mode:\n\n```bash\nstratix new\n```\n\nYou'll be prompted for:\n- **Project name** - Name of your project directory\n- **Package manager** - npm, pnpm, or yarn\n- **Project structure** - DDD or Modular\n- **Git initialization** - Whether to initialize a git repository\n- **Install dependencies** - Whether to install dependencies automatically\n\n### Non-Interactive Mode\n\nYou can also create a project with command-line options:\n\n```bash\nstratix new my-app --pm pnpm --structure ddd\n```\n\n**Options:**\n- `--pm <manager>` - Package manager (npm, pnpm, yarn)\n- `--structure <type>` - Project structure (ddd, modular)\n- `--no-git` - Skip git initialization\n- `--skip-install` - Skip dependency installation\n\n### Examples\n\n```bash\n# Create with pnpm and DDD structure\nstratix new my-ecommerce --pm pnpm --structure ddd\n\n# Create without git and skip install\nstratix new my-api --no-git --skip-install\n\n# Create with modular structure\nstratix new my-service --structure modular\n```\n\n## Project Structure\n\nAfter creation, your project will have this structure:\n\n```\nmy-app/\n├── src/\n│   ├── domain/              # Domain layer (entities, value objects)\n│   ├── application/         # Application layer (use cases, CQRS)\n│   └── infrastructure/      # Infrastructure layer (plugins, adapters)\n├── tests/                   # Test files\n├── package.json\n├── tsconfig.json\n├── .eslintrc.json\n├── .prettierrc\n└── README.md\n```\n\nLearn more about [Project Structure](./project-structure).\n\n## Install Extensions\n\nStratix provides 14 official extensions for common functionality:\n\n```bash\ncd my-app\n\n# Install HTTP server\nstratix add http\n\n# Install database\nstratix add postgres\n\n# Install AI provider\nstratix add ai-openai\n\n# Install validation\nstratix add validation\n\n# List all available extensions\nstratix add list\n```\n\n**Note:** The `stratix add` command uses simplified names for official Stratix extensions. External dependencies (like `pg`, `redis`, etc.) are automatically installed from the public npm registry.\n\n**Available Extensions:**\n\n### Production Extensions\n- `http` - Fastify HTTP server\n- `validation` - Zod schema validation\n- `mappers` - Entity-to-DTO mapping\n- `auth` - JWT authentication & RBAC\n- `errors` - Structured error handling\n\n### Database & Infrastructure\n- `postgres` - PostgreSQL integration\n- `mongodb` - MongoDB integration\n- `redis` - Redis caching\n- `rabbitmq` - RabbitMQ messaging\n- `opentelemetry` - Observability\n- `secrets` - Secrets management\n\n### AI Providers\n- `ai-openai` - OpenAI LLM provider\n- `ai-anthropic` - Anthropic Claude provider\n\n## Build and Run\n\n### Install Dependencies\n\nIf you skipped installation during project creation:\n\n```bash\ncd my-app\nnpm install\n# or\npnpm install\n# or\nyarn install\n```\n\n### Build the Project\n\n```bash\nnpm run build\n# or\npnpm build\n# or\nyarn build\n```\n\n### Run in Development Mode\n\n```bash\nnpm run dev\n# or\npnpm dev\n# or\nyarn dev\n```\n\n### Run in Production Mode\n\n```bash\nnpm start\n# or\npnpm start\n# or\nyarn start\n```\n\n## Verify Your Installation\n\nCreate a simple entity to verify everything works:\n\n```bash\n# Generate an entity\nstratix generate entity Product --props '[{\"name\":\"id\",\"type\":\"string\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"number\"}]'\n\n# Build the project\nnpm run build\n\n# If it builds successfully, you're all set! 🎉\n```\n\n## IDE Setup\n\n### VS Code (Recommended)\n\nInstall these extensions for the best experience:\n\n- **ESLint** - Linting support\n- **Prettier** - Code formatting\n- **TypeScript and JavaScript Language Features** - Built-in\n\n### WebStorm / IntelliJ IDEA\n\nWebStorm has built-in support for TypeScript, ESLint, and Prettier.\n\n## Troubleshooting\n\n### Node.js Version Issues\n\nIf you encounter errors about Node.js version:\n\n```bash\n# Check your version\nnode --version\n\n# Upgrade Node.js if needed\n# Using nvm:\nnvm install 18\nnvm use 18\n\n# Or download from nodejs.org\n```\n\n### Permission Errors (npm global install)\n\nIf you get permission errors installing globally with npm:\n\n```bash\n# Option 1: Use npx (no global install needed)\nnpx @stratix/cli new my-app\n\n# Option 2: Fix npm permissions\n# See: https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally\n```\n\n### Package Manager Not Found\n\nEnsure your chosen package manager is installed:\n\n```bash\n# Install pnpm\nnpm install -g pnpm\n\n# Install yarn\nnpm install -g yarn\n```\n\n### CLI Version Mismatch\n\nIf you see version-related errors or unexpected behavior:\n\n```bash\n# Check CLI version\nstratix --version\n\n# Update to latest\nnpm update -g @stratix/cli\n# or\npnpm update -g @stratix/cli\n# or\nyarn global upgrade @stratix/cli\n```\n\n## Next Steps\n\nNow that you have Stratix installed:\n\n1. **[Quick Start](./quick-start)** - Build your first application in 5 minutes\n2. **[Project Structure](./project-structure)** - Understand the project organization\n3. **[Core Concepts](../core-concepts/architecture-overview)** - Learn the fundamental concepts\n4. **[CLI Reference](../cli/cli-overview)** - Explore all CLI commands\n\n## Getting Help\n\nIf you encounter issues:\n\n- Check the [GitHub Issues](https://github.com/stratix-dev/stratix/issues)\n- Ask in [GitHub Discussions](https://github.com/stratix-dev/stratix/discussions)\n",
      "metadata": {
        "type": "docs",
        "category": "getting-started",
        "source": "docs/getting-started/installation.md",
        "title": "Installation"
      }
    },
    {
      "id": "docs-getting-started-introduction",
      "content": "\n# What is Stratix?\n\n> [!WARNING]\n> **PRE-RELEASE - ACTIVE DEVELOPMENT**\n>\n> Stratix is currently in **active development** and **NOT ready for production use**. The API is unstable and may change significantly without notice. Use at your own risk for experimental projects only.\n\n**Stratix** is a modern TypeScript framework designed for building **scalable, maintainable, and production-ready applications** with **AI agents as first-class citizens**.\n\n\n## Why Stratix?\n\nStratix combines proven enterprise patterns with cutting-edge AI capabilities to help you build applications that are:\n\n### AI-First\n- **AI Agents as Domain Entities** - Treat AI agents like any other domain object\n- **Production-Ready AI Patterns** - Built-in orchestration, memory management, and execution tracing\n- **Multiple LLM Providers** - OpenAI, Anthropic, and custom providers out of the box\n- **Agent Testing** - Comprehensive testing utilities for AI agents\n\n### Modular & Scalable\n- **Bounded Contexts** - Portable domain modules that work in monoliths or microservices\n- **Plugin Architecture** - Extensible system with lifecycle management and health checks\n- **Dependency Injection** - Clean, testable code with automatic dependency resolution\n- **CQRS Pattern** - Command Query Responsibility Segregation for scalable architectures\n\n### Enterprise-Ready\n- **Domain-Driven Design** - Entity, AggregateRoot, ValueObject, and Repository patterns\n- **Hexagonal Architecture** - Clean separation of concerns with ports and adapters\n- **Result Pattern** - Explicit error handling without exceptions\n- **Type Safety** - Full TypeScript strict mode with phantom types\n- **Production Extensions** - HTTP, validation, authentication, observability\n\n### Developer Experience\n- **Powerful CLI** - Scaffold projects and generate code in seconds\n- **13 Official Plugins** - Database, messaging, HTTP, AI, and utility plugins\n- **Comprehensive Testing** - Built-in testing utilities and mocks\n- **Complete Documentation** - Guides, tutorials, and API reference\n\n## Key Features\n\n```mermaid\ngraph TB\n    A[Stratix Framework] --> B[Core Primitives]\n    A --> C[AI Agents]\n    A --> D[Plugin System]\n    A --> E[CQRS]\n    \n    B --> B1[Entity & AggregateRoot]\n    B --> B2[Value Objects]\n    B --> B3[Result Pattern]\n    \n    C --> C1[AIAgent Base Class]\n    C --> C2[LLM Providers]\n    C --> C3[Agent Orchestration]\n    \n    D --> D1[Database Plugins]\n    D --> D2[HTTP Plugin]\n    D --> D3[Messaging Plugin]\n    \n    E --> E1[Commands]\n    E --> E2[Queries]\n    E --> E3[Events]\n```\n\n### Domain Primitives\n- **Entity** - Base class with identity and timestamps\n- **AggregateRoot** - Entity with domain event support\n- **ValueObject** - Immutable value objects\n- **EntityId** - Type-safe identifiers with phantom types\n- **Result** - Type-safe error handling\n\n### AI Agent System\n- **AIAgent** - Base class for AI agents as domain entities\n- **LLMProvider** - Interface for LLM integrations (OpenAI, Anthropic)\n- **AgentOrchestrator** - Multi-agent workflow management\n- **AgentMemory** - Conversation history and context management\n- **ExecutionTrace** - Detailed execution tracking and debugging\n\n### Plugin Ecosystem\n- **PostgreSQL** - Relational database integration\n- **MongoDB** - Document database integration\n- **Redis** - Caching and session management\n- **RabbitMQ** - Message broker for event-driven architecture\n- **Fastify** - High-performance HTTP server\n- **OpenTelemetry** - Observability (traces, metrics, logs)\n- **Zod Validation** - Schema validation\n- **JWT Auth** - Authentication and RBAC authorization\n- **And more...**\n\n### Built-in Value Objects\n- **Money** - Monetary values with currency support\n- **Email** - Email validation\n- **PhoneNumber** - International phone numbers\n- **URL** - URL validation\n- **UUID** - UUID generation\n- **DateRange** - Date ranges\n- **Percentage** - Percentage values\n- **Address** - Physical addresses\n\n## Quick Example\n\n```typescript\nimport { ApplicationBuilder } from '@stratix/runtime';\nimport { FastifyHTTPPlugin } from '@stratix/http-fastify';\nimport { PostgresPlugin } from '@stratix/database-postgres';\nimport { OpenAIProvider } from '@stratix/ai-openai';\n\n// Build your application\nconst app = await ApplicationBuilder.create()\n  .useContainer(new AwilixContainer())\n  .useLogger(new ConsoleLogger())\n  .usePlugin(new PostgresPlugin({ /* config */ }))\n  .usePlugin(new FastifyHTTPPlugin({ port: 3000 }))\n  .build();\n\n// Start the application\nawait app.start();\n\n// Create an AI agent\nclass CustomerSupportAgent extends AIAgent<string, string> {\n  readonly name = 'Customer Support';\n  readonly version = AgentVersionFactory.create('1.0.0');\n  readonly capabilities = [AgentCapabilities.TEXT_GENERATION];\n  \n  protected async execute(input: string): Promise<AgentResult<string>> {\n    const response = await this.llmProvider.chat({\n      model: 'gpt-4o',\n      messages: [\n        { role: 'system', content: 'You are a helpful customer support agent.' },\n        { role: 'user', content: input }\n      ]\n    });\n    \n    return AgentResult.success(response.content, response.usage);\n  }\n}\n```\n\n## Who is Stratix For?\n\nStratix is ideal for:\n\n- **Enterprise Teams** building scalable, maintainable applications\n- **AI Developers** who want production-ready AI agent patterns\n- **Backend Engineers** who value clean architecture and type safety\n- **Startups** that need to move fast without sacrificing quality\n- **Teams** transitioning from monoliths to microservices\n\n## Comparison with Other Frameworks\n\n| Feature | Stratix | NestJS | LangChain | Express |\n|---------|---------|--------|-----------|---------|\n| **AI Agents as First-Class Citizens** | ✅ | ❌ | ✅ | ❌ |\n| **Domain-Driven Design** | ✅ | ⚠️ | ❌ | ❌ |\n| **Hexagonal Architecture** | ✅ | ⚠️ | ❌ | ❌ |\n| **CQRS Built-in** | ✅ | ⚠️ | ❌ | ❌ |\n| **Result Pattern** | ✅ | ❌ | ❌ | ❌ |\n| **Plugin System** | ✅ | ✅ | ⚠️ | ⚠️ |\n| **Type Safety** | ✅ | ✅ | ⚠️ | ⚠️ |\n| **Code Generation CLI** | ✅ | ✅ | ❌ | ❌ |\n| **Bounded Contexts** | ✅ | ❌ | ❌ | ❌ |\n| **Production-Ready AI** | ✅ | ❌ | ⚠️ | ❌ |\n\n> **Legend**: ✅ Full Support | ⚠️ Partial Support | ❌ Not Supported\n\n## Philosophy\n\nStratix is built on these core principles:\n\n1. **AI-First** - AI agents should be treated as domain entities, not afterthoughts\n2. **Domain-Driven** - Business logic belongs in the domain layer\n3. **Explicit over Implicit** - Use Result pattern instead of throwing exceptions\n4. **Modular** - Build portable modules that work anywhere\n5. **Type-Safe** - Leverage TypeScript's type system for safety\n6. **Production-Ready** - Enterprise patterns from day one\n\n## Next Steps\n\nReady to get started? Here's what to do next:\n\n1. **[Install Stratix](./installation)** - Set up your development environment\n2. **[Quick Start](./quick-start)** - Build your first application in 5 minutes\n3. **[Project Structure](./project-structure)** - Understand how Stratix projects are organized\n4. **[Core Concepts](../core-concepts/architecture-overview)** - Learn the fundamental concepts\n\n## Community & Support\n\n- **GitHub**: [github.com/stratix-dev/stratix](https://github.com/stratix-dev/stratix)\n- **Issues**: [Report bugs or request features](https://github.com/stratix-dev/stratix/issues)\n- **Discussions**: [Ask questions and share ideas](https://github.com/stratix-dev/stratix/discussions)\n\n## License\n\nStratix is [MIT licensed](https://github.com/stratix-dev/stratix/blob/main/LICENSE).\n",
      "metadata": {
        "type": "docs",
        "category": "getting-started",
        "source": "docs/getting-started/introduction.md",
        "title": "What is Stratix?"
      }
    },
    {
      "id": "docs-getting-started-project-structure",
      "content": "\n# Project Structure\n\nStratix supports two project structures: **DDD (Domain-Driven Design)** and **Modular**. Both follow clean architecture principles with clear separation of concerns.\n\n## DDD Structure (Recommended)\n\nThe DDD structure organizes code by architectural layers following hexagonal architecture:\n\n```\nmy-app/\n├── src/\n│   ├── domain/                    # Domain Layer (Business Logic)\n│   │   ├── entities/              # Domain entities and aggregates\n│   │   ├── value-objects/         # Immutable value objects\n│   │   ├── repositories/          # Repository interfaces\n│   │   ├── services/              # Domain services\n│   │   └── events/                # Domain events\n│   │\n│   ├── application/               # Application Layer (Use Cases)\n│   │   ├── commands/              # CQRS commands\n│   │   ├── queries/               # CQRS queries\n│   │   ├── handlers/              # Command/query handlers\n│   │   └── services/              # Application services\n│   │\n│   ├── infrastructure/            # Infrastructure Layer (Technical Details)\n│   │   ├── repositories/          # Repository implementations\n│   │   ├── http/                  # HTTP controllers and routes\n│   │   ├── database/              # Database configurations\n│   │   ├── messaging/             # Message broker integrations\n│   │   └── plugins/               # Custom plugins\n│   │\n│   └── index.ts                   # Application entry point\n│\n├── tests/                         # Test files (mirrors src structure)\n│   ├── unit/\n│   ├── integration/\n│   └── e2e/\n│\n├── package.json\n├── tsconfig.json\n├── .eslintrc.json\n├── .prettierrc\n└── README.md\n```\n\n### Layer Responsibilities\n\n#### Domain Layer (`src/domain/`)\n\nThe **core business logic** layer. Contains:\n\n- **Entities** - Objects with identity (User, Product, Order)\n- **Value Objects** - Immutable objects (Email, Money, Address)\n- **Repositories** - Interfaces for data access\n- **Domain Services** - Business logic that doesn't belong to entities\n- **Domain Events** - Events that represent business occurrences\n\n**Rules:**\n- ❌ No dependencies on other layers\n- ❌ No framework-specific code\n- ✅ Pure business logic\n- ✅ Framework-agnostic\n\n**Example:**\n```typescript\n// src/domain/entities/Product.ts\nimport { AggregateRoot, EntityId } from '@stratix/core';\n\nexport class Product extends AggregateRoot<'Product'> {\n  constructor(\n    id: EntityId<'Product'>,\n    private name: string,\n    private price: number,\n    createdAt: Date,\n    updatedAt: Date\n  ) {\n    super(id, createdAt, updatedAt);\n  }\n\n  updatePrice(newPrice: number): void {\n    if (newPrice < 0) {\n      throw new Error('Price cannot be negative');\n    }\n    this.price = newPrice;\n    this.touch();\n  }\n}\n```\n\n#### Application Layer (`src/application/`)\n\nThe **use case** layer. Contains:\n\n- **Commands** - Write operations (CreateProduct, UpdateOrder)\n- **Queries** - Read operations (GetProductById, ListOrders)\n- **Handlers** - Command and query handlers\n- **Application Services** - Orchestration logic\n\n**Rules:**\n- ✅ Depends on Domain layer\n- ❌ No dependencies on Infrastructure layer\n- ✅ Orchestrates domain objects\n- ✅ Implements use cases\n\n**Example:**\n```typescript\n// src/application/commands/CreateProduct.ts\nimport { Command } from '@stratix/core';\n\nexport class CreateProductCommand implements Command {\n  constructor(\n    public readonly name: string,\n    public readonly price: number\n  ) {}\n}\n\n// src/application/handlers/CreateProductHandler.ts\nimport { CommandHandler, Result } from '@stratix/core';\n\nexport class CreateProductHandler implements CommandHandler<CreateProductCommand, Product> {\n  constructor(private productRepository: IProductRepository) {}\n\n  async handle(command: CreateProductCommand): Promise<Result<Product>> {\n    const product = new Product(\n      EntityId.create<'Product'>(),\n      command.name,\n      command.price,\n      new Date(),\n      new Date()\n    );\n\n    await this.productRepository.save(product);\n    return Success.create(product);\n  }\n}\n```\n\n#### Infrastructure Layer (`src/infrastructure/`)\n\nThe **technical implementation** layer. Contains:\n\n- **Repository Implementations** - Database access\n- **HTTP Controllers** - REST API endpoints\n- **Database Configurations** - Connection setup\n- **External Integrations** - Third-party services\n- **Plugins** - Custom plugins\n\n**Rules:**\n- ✅ Depends on Domain and Application layers\n- ✅ Framework-specific code\n- ✅ External service integrations\n- ✅ Technical implementations\n\n**Example:**\n```typescript\n// src/infrastructure/repositories/PostgresProductRepository.ts\nimport { IProductRepository } from '../../domain/repositories/IProductRepository';\n\nexport class PostgresProductRepository implements IProductRepository {\n  constructor(private db: Database) {}\n\n  async save(product: Product): Promise<void> {\n    await this.db.query(\n      'INSERT INTO products (id, name, price) VALUES ($1, $2, $3)',\n      [product.id, product.name, product.price]\n    );\n  }\n\n  async findById(id: EntityId<'Product'>): Promise<Product | null> {\n    const result = await this.db.query(\n      'SELECT * FROM products WHERE id = $1',\n      [id]\n    );\n    return result.rows[0] ? this.toDomain(result.rows[0]) : null;\n  }\n}\n```\n\n---\n\n## Modular Structure\n\nThe modular structure organizes code by feature/bounded context:\n\n```\nmy-app/\n├── src/\n│   ├── modules/\n│   │   ├── products/              # Products bounded context\n│   │   │   ├── domain/\n│   │   │   ├── application/\n│   │   │   ├── infrastructure/\n│   │   │   └── index.ts\n│   │   │\n│   │   ├── orders/                # Orders bounded context\n│   │   │   ├── domain/\n│   │   │   ├── application/\n│   │   │   ├── infrastructure/\n│   │   │   └── index.ts\n│   │   │\n│   │   └── customers/             # Customers bounded context\n│   │       ├── domain/\n│   │       ├── application/\n│   │       ├── infrastructure/\n│   │       └── index.ts\n│   │\n│   ├── shared/                    # Shared kernel\n│   │   ├── value-objects/\n│   │   └── utils/\n│   │\n│   └── index.ts\n│\n├── tests/\n├── package.json\n└── tsconfig.json\n```\n\n### When to Use Modular Structure\n\nUse modular structure when:\n- ✅ Building microservices\n- ✅ Multiple bounded contexts\n- ✅ Team-based development (one team per module)\n- ✅ Need to extract modules to separate services later\n\n---\n\n## File Naming Conventions\n\nStratix follows these naming conventions:\n\n### TypeScript Files\n\n- **Entities**: `PascalCase.ts` - `Product.ts`, `Order.ts`\n- **Value Objects**: `PascalCase.ts` - `Email.ts`, `Money.ts`\n- **Commands**: `PascalCaseCommand.ts` - `CreateProductCommand.ts`\n- **Queries**: `PascalCaseQuery.ts` - `GetProductByIdQuery.ts`\n- **Handlers**: `PascalCaseHandler.ts` - `CreateProductHandler.ts`\n- **Repositories**: `IPascalCaseRepository.ts` (interface), `ConcretePascalCaseRepository.ts` (implementation)\n- **Plugins**: `PascalCasePlugin.ts` - `DatabasePlugin.ts`\n\n### Test Files\n\n- **Unit Tests**: `*.test.ts` or `*.spec.ts`\n- **Integration Tests**: `*.integration.test.ts`\n- **E2E Tests**: `*.e2e.test.ts`\n\n---\n\n## Import Paths\n\n### Absolute Imports (Recommended)\n\nConfigure `tsconfig.json` for absolute imports:\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"./src\",\n    \"paths\": {\n      \"@domain/*\": [\"domain/*\"],\n      \"@application/*\": [\"application/*\"],\n      \"@infrastructure/*\": [\"infrastructure/*\"]\n    }\n  }\n}\n```\n\nUsage:\n```typescript\nimport { Product } from '@domain/entities/Product';\nimport { CreateProductCommand } from '@application/commands/CreateProduct';\n```\n\n### Relative Imports\n\n```typescript\nimport { Product } from '../../domain/entities/Product';\nimport { IProductRepository } from '../../domain/repositories/IProductRepository';\n```\n\n---\n\n## Configuration Files\n\n### `package.json`\n\nProject metadata and dependencies:\n\n```json\n{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"dev\": \"tsx watch src/index.ts\",\n    \"start\": \"node dist/index.js\",\n    \"test\": \"vitest\",\n    \"lint\": \"eslint src\",\n    \"format\": \"prettier --write src\"\n  }\n}\n```\n\n### `tsconfig.json`\n\nTypeScript configuration:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n### `.eslintrc.json`\n\nESLint configuration for code quality:\n\n```json\n{\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:@typescript-eslint/recommended\"\n  ],\n  \"parser\": \"@typescript-eslint/parser\",\n  \"plugins\": [\"@typescript-eslint\"],\n  \"root\": true\n}\n```\n\n### `.prettierrc`\n\nPrettier configuration for code formatting:\n\n```json\n{\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"tabWidth\": 2,\n  \"trailingComma\": \"es5\"\n}\n```\n\n---\n\n## Best Practices\n\n### 1. Keep Layers Separate\n\n```typescript\n// ❌ Bad: Domain depends on infrastructure\nimport { Database } from '@infrastructure/database';\n\nexport class Product {\n  save() {\n    Database.query('INSERT...'); // Domain shouldn't know about database\n  }\n}\n\n// ✅ Good: Use repository interface\nexport class Product {\n  // Domain logic only\n}\n\n// Infrastructure implements the interface\nexport class PostgresProductRepository implements IProductRepository {\n  async save(product: Product): Promise<void> {\n    await this.db.query('INSERT...');\n  }\n}\n```\n\n### 2. Use Dependency Injection\n\n```typescript\n// ❌ Bad: Hard-coded dependencies\nexport class CreateProductHandler {\n  private repository = new PostgresProductRepository();\n}\n\n// ✅ Good: Inject dependencies\nexport class CreateProductHandler {\n  constructor(private repository: IProductRepository) {}\n}\n```\n\n### 3. Organize by Feature, Not by Type\n\n```typescript\n// ❌ Bad: Organized by type\nsrc/\n  controllers/\n    ProductController.ts\n    OrderController.ts\n  services/\n    ProductService.ts\n    OrderService.ts\n\n// ✅ Good: Organized by feature\nsrc/\n  modules/\n    products/\n      ProductController.ts\n      ProductService.ts\n    orders/\n      OrderController.ts\n      OrderService.ts\n```\n\n---\n\n## Next Steps\n\n- **[Core Concepts](../core-concepts/architecture-overview)** - Learn about hexagonal architecture\n- **[CLI Reference](../cli/cli-overview)** - Generate code with the CLI\n- **[Bounded Contexts](../core-concepts/bounded-contexts)** - Understand modular architecture\n",
      "metadata": {
        "type": "docs",
        "category": "getting-started",
        "source": "docs/getting-started/project-structure.md",
        "title": "Project Structure"
      }
    },
    {
      "id": "docs-getting-started-quick-start",
      "content": "\n# Quick Start\n\nBuild a complete CRUD API with Stratix in just 5 minutes. This tutorial will guide you through creating a simple product management system.\n\n## What You'll Build\n\nA REST API for managing products with:\n- Domain entities and value objects\n- CQRS commands and queries\n- HTTP endpoints\n- In-memory repository\n- Type-safe error handling\n\n## Step 1: Create a New Project\n\n```bash\n# Create a new project\nstratix new product-api --pm pnpm --structure ddd\n\n# Navigate to the project\ncd product-api\n```\n\n## Step 2: Add HTTP Extension\n\n```bash\n# Install the Fastify HTTP plugin\nstratix add http\n```\n\nThis installs `@stratix/http-fastify` and its dependencies.\n\n## Step 3: Generate Domain Entity\n\n```bash\n# Generate a Product entity\nstratix generate entity Product --props '[\n  {\"name\":\"id\",\"type\":\"string\"},\n  {\"name\":\"name\",\"type\":\"string\"},\n  {\"name\":\"price\",\"type\":\"number\"},\n  {\"name\":\"stock\",\"type\":\"number\"}\n]'\n```\n\nThis creates:\n- `src/domain/entities/Product.ts` - The Product entity\n- Type-safe entity with validation\n\n## Step 4: Generate Repository\n\n```bash\n# Generate repository for Product\nstratix generate repository Product\n```\n\nThis creates:\n- `src/domain/repositories/IProductRepository.ts` - Repository interface\n- `src/infrastructure/repositories/InMemoryProductRepository.ts` - In-memory implementation\n\n## Step 5: Generate Commands\n\n```bash\n# Create Product command\nstratix generate command CreateProduct --props '[\n  {\"name\":\"name\",\"type\":\"string\"},\n  {\"name\":\"price\",\"type\":\"number\"},\n  {\"name\":\"stock\",\"type\":\"number\"}\n]'\n\n# Update Product command\nstratix generate command UpdateProduct --props '[\n  {\"name\":\"id\",\"type\":\"string\"},\n  {\"name\":\"name\",\"type\":\"string\"},\n  {\"name\":\"price\",\"type\":\"number\"},\n  {\"name\":\"stock\",\"type\":\"number\"}\n]'\n\n# Delete Product command\nstratix generate command DeleteProduct --props '[\n  {\"name\":\"id\",\"type\":\"string\"}\n]'\n```\n\nThis creates commands and their handlers in:\n- `src/application/commands/` - Command definitions\n- `src/application/handlers/` - Command handlers\n\n## Step 6: Generate Queries\n\n```bash\n# Get Product by ID query\nstratix generate query GetProductById --props '[\n  {\"name\":\"id\",\"type\":\"string\"}\n]' --return-type \"Product\"\n\n# List all Products query\nstratix generate query ListProducts --return-type \"Product[]\"\n```\n\nThis creates queries and their handlers.\n\n## Step 7: Create HTTP Routes\n\nCreate `src/infrastructure/http/ProductRoutes.ts`:\n\n```typescript\nimport { FastifyHTTPPlugin, HttpErrorImpl } from '@stratix/http-fastify';\nimport { CommandBus, QueryBus } from '@stratix/core';\nimport { CreateProductCommand } from '../../application/commands/CreateProduct';\nimport { GetProductByIdQuery } from '../../application/queries/GetProductById';\nimport { ListProductsQuery } from '../../application/queries/ListProducts';\n\nexport function registerProductRoutes(\n  http: FastifyHTTPPlugin,\n  commandBus: CommandBus,\n  queryBus: QueryBus\n) {\n  // Create product\n  http.post('/products', async (request) => {\n    const { name, price, stock } = request.body;\n    \n    const result = await commandBus.dispatch(\n      new CreateProductCommand(name, price, stock)\n    );\n    \n    if (result.isFailure) {\n      throw HttpErrorImpl.badRequest(result.error.message);\n    }\n    \n    return { statusCode: 201, body: result.value };\n  });\n\n  // Get product by ID\n  http.get('/products/:id', async (request) => {\n    const { id } = request.params;\n    \n    const result = await queryBus.execute(\n      new GetProductByIdQuery(id)\n    );\n    \n    if (result.isFailure) {\n      throw HttpErrorImpl.notFound('Product not found');\n    }\n    \n    return { body: result.value };\n  });\n\n  // List all products\n  http.get('/products', async (request) => {\n    const result = await queryBus.execute(new ListProductsQuery());\n    \n    if (result.isFailure) {\n      throw HttpErrorImpl.internalServerError(result.error.message);\n    }\n    \n    return { body: result.value };\n  });\n}\n```\n\n## Step 8: Configure the Application\n\nUpdate `src/index.ts`:\n\n```typescript\nimport { ApplicationBuilder } from '@stratix/runtime';\nimport { AwilixContainer } from '@stratix/di-awilix';\nimport { ConsoleLogger } from '@stratix/core';\nimport { FastifyHTTPPlugin } from '@stratix/http-fastify';\nimport { InMemoryCommandBus, InMemoryQueryBus } from '@stratix/core';\nimport { registerProductRoutes } from './infrastructure/http/ProductRoutes';\n\nasync function bootstrap() {\n  // Create buses\n  const commandBus = new InMemoryCommandBus();\n  const queryBus = new InMemoryQueryBus();\n  \n  // Create HTTP plugin\n  const httpPlugin = new FastifyHTTPPlugin({ port: 3000 });\n  \n  // Register routes\n  registerProductRoutes(httpPlugin, commandBus, queryBus);\n  \n  // Build application\n  const app = await ApplicationBuilder.create()\n    .useContainer(new AwilixContainer())\n    .useLogger(new ConsoleLogger())\n    .usePlugin(httpPlugin)\n    .build();\n  \n  // Start application\n  await app.start();\n  \n  console.log('Server running on http://localhost:3000');\n}\n\nbootstrap().catch(console.error);\n```\n\n## Step 9: Build and Run\n\n```bash\n# Build the project\npnpm build\n\n# Run the server\npnpm start\n```\n\nYou should see:\n```\nServer running on http://localhost:3000\n```\n\n## Step 10: Test Your API\n\n### Create a Product\n\n```bash\ncurl -X POST http://localhost:3000/products \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Laptop\",\n    \"price\": 999.99,\n    \"stock\": 10\n  }'\n```\n\n### Get All Products\n\n```bash\ncurl http://localhost:3000/products\n```\n\n### Get Product by ID\n\n```bash\ncurl http://localhost:3000/products/{id}\n```\n\n## What You've Learned\n\nCongratulations! You've just built a complete CRUD API with:\n\n- **Domain-Driven Design** - Entities and repositories\n- **CQRS Pattern** - Commands and queries with handlers\n- **HTTP Server** - Fastify integration\n- **Type Safety** - Full TypeScript support\n- **Result Pattern** - Explicit error handling\n- **Clean Architecture** - Separation of concerns\n\n## Next Steps\n\nNow that you've built your first application, explore:\n\n1. **[Project Structure](./project-structure)** - Understand the project organization\n2. **[Core Concepts](../core-concepts/architecture-overview)** - Learn DDD and hexagonal architecture\n3. **[Core Concepts](../core-concepts/architecture-overview)** - Understand Stratix architecture\n4. **[AI Agents](../ai-agents/ai-agents-overview)** - Build AI-powered features\n5. **[AI Agents](../ai-agents/ai-agents-overview)** - Add AI capabilities to your app\n\n## Add More Features\n\n### Add Validation\n\n```bash\nstratix add validation\n```\n\nThen add Zod schemas to validate requests.\n\n### Add Database\n\n```bash\nstratix add postgres\n```\n\nReplace the in-memory repository with PostgreSQL.\n\n### Add AI Agent\n\n```bash\nstratix add ai-openai\n```\n\nCreate an AI agent for product recommendations.\n\n### Add Authentication\n\n```bash\nstratix add auth\n```\n\nProtect your endpoints with JWT authentication.\n\n## Full Example\n\nThe complete code for this tutorial is available in the [examples directory](https://github.com/stratix-dev/stratix/tree/main/examples/quick-start).\n\n## Getting Help\n\n- **Documentation**: [Full documentation](../core-concepts/architecture-overview)\n- **Examples**: [More examples](https://github.com/stratix-dev/stratix/tree/main/examples)\n- **Community**: [GitHub Discussions](https://github.com/stratix-dev/stratix/discussions)\n",
      "metadata": {
        "type": "docs",
        "category": "getting-started",
        "source": "docs/getting-started/quick-start.md",
        "title": "Quick Start"
      }
    },
    {
      "id": "docs-intro",
      "content": "\n# Stratix Framework\n\n> [!WARNING]\n> **PRE-RELEASE - ACTIVE DEVELOPMENT**\n>\n> Stratix is currently in **active development** and **NOT ready for production use**. The API is unstable and may change significantly without notice. Use at your own risk for experimental projects only.\n\n**Stratix** is an AI-first, modular, scalable, and enterprise-ready TypeScript framework for building modern applications.\n\n## New: Stratix Copilot\n\n**AI-powered coding assistant for Stratix** - Generate DDD/CQRS code with GitHub Copilot integration.\n\n- **Context-Aware** - Understands your project structure\n- **Framework Knowledge** - Trained on complete Stratix documentation\n- **Smart Generation** - Entities, commands, queries, value objects\n- **One-Click Files** - Generate and save directly from chat\n\n**[Get Started with Stratix Copilot →](./stratix-copilot/overview)**\n\n## Get Started\n\n- **[Introduction](./getting-started/introduction)** - Learn what Stratix is and why you should use it\n- **[Installation](./getting-started/installation)** - Set up your development environment\n- **[Quick Start](./getting-started/quick-start)** - Build your first application in 5 minutes\n\n## Key Features\n\n- **AI-First** - AI agents as domain entities + Stratix Copilot VS Code extension\n- **Modular** - Portable bounded contexts\n- **Enterprise-Ready** - DDD, CQRS, Hexagonal Architecture\n- **Developer Experience** - Powerful CLI, Copilot integration, and comprehensive docs\n",
      "metadata": {
        "type": "docs",
        "category": "intro.md",
        "source": "docs/intro.md",
        "title": "intro"
      }
    },
    {
      "id": "docs-plugins-creating-plugins",
      "content": "\n# Creating Plugins\n\nLearn how to create custom plugins to extend Stratix functionality.\n\n## Plugin Template\n\n```typescript\nimport { Plugin, PluginContext, PluginMetadata } from '@stratix/core';\n\nexport interface MyPluginConfig {\n  // Your configuration options\n}\n\nexport class MyPlugin implements Plugin {\n  readonly metadata: PluginMetadata = {\n    name: 'my-plugin',\n    version: '1.0.0',\n    description: 'My custom plugin',\n    dependencies: [], // Required plugins\n    optionalDependencies: [] // Optional plugins\n  };\n\n  constructor(private config: MyPluginConfig) {}\n\n  async initialize(context: PluginContext): Promise<void> {\n    // Set up resources, register services\n  }\n\n  async start(context: PluginContext): Promise<void> {\n    // Start servers, subscribe to events\n  }\n\n  async stop(): Promise<void> {\n    // Clean up resources\n  }\n\n  async healthCheck(): Promise<HealthCheckResult> {\n    return { status: 'healthy' };\n  }\n}\n```\n\n## Step-by-Step Guide\n\n### 1. Create Plugin Class\n\n```typescript\nimport { Plugin } from '@stratix/core';\n\nexport class EmailPlugin implements Plugin {\n  readonly metadata = {\n    name: 'email',\n    version: '1.0.0'\n  };\n}\n```\n\n### 2. Add Configuration\n\n```typescript\nexport interface EmailConfig {\n  host: string;\n  port: number;\n  user: string;\n  password: string;\n}\n\nexport class EmailPlugin implements Plugin {\n  constructor(private config: EmailConfig) {}\n}\n```\n\n### 3. Implement Initialize\n\n```typescript\nasync initialize(context: PluginContext): Promise<void> {\n  // Create email service\n  const emailService = new EmailService(this.config);\n  \n  // Register in container\n  context.container.register('emailService', () => emailService);\n  \n  context.logger.info('Email plugin initialized');\n}\n```\n\n### 4. Implement Start\n\n```typescript\nasync start(context: PluginContext): Promise<void> {\n  const emailService = context.container.resolve('emailService');\n  await emailService.connect();\n  \n  context.logger.info('Email service connected');\n}\n```\n\n### 5. Implement Stop\n\n```typescript\nasync stop(): Promise<void> {\n  await this.emailService?.disconnect();\n}\n```\n\n### 6. Add Health Check\n\n```typescript\nasync healthCheck(): Promise<HealthCheckResult> {\n  try {\n    await this.emailService.ping();\n    return { status: 'healthy' };\n  } catch (error) {\n    return {\n      status: 'unhealthy',\n      error: error.message\n    };\n  }\n}\n```\n\n## Complete Example\n\n```typescript\nimport { Plugin, PluginContext } from '@stratix/core';\nimport nodemailer, { Transporter } from 'nodemailer';\n\nexport interface EmailConfig {\n  host: string;\n  port: number;\n  secure: boolean;\n  auth: {\n    user: string;\n    pass: string;\n  };\n}\n\nexport class EmailPlugin implements Plugin {\n  readonly metadata = {\n    name: 'email',\n    version: '1.0.0',\n    description: 'Email sending plugin using nodemailer',\n    dependencies: ['logger']\n  };\n\n  private transporter?: Transporter;\n\n  constructor(private config: EmailConfig) {}\n\n  async initialize(context: PluginContext): Promise<void> {\n    this.transporter = nodemailer.createTransport(this.config);\n\n    // Register email service\n    context.container.register('emailService', () => ({\n      send: async (to: string, subject: string, html: string) => {\n        await this.transporter!.sendMail({ to, subject, html });\n      }\n    }));\n\n    context.logger.info('Email plugin initialized');\n  }\n\n  async start(context: PluginContext): Promise<void> {\n    // Verify connection\n    await this.transporter!.verify();\n    context.logger.info('Email service ready');\n  }\n\n  async stop(): Promise<void> {\n    this.transporter?.close();\n  }\n\n  async healthCheck(): Promise<HealthCheckResult> {\n    try {\n      await this.transporter!.verify();\n      return { status: 'healthy' };\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        error: error.message\n      };\n    }\n  }\n}\n```\n\n## Usage\n\n```typescript\nimport { ApplicationBuilder } from '@stratix/runtime';\nimport { EmailPlugin } from './plugins/email.plugin';\n\nconst app = await ApplicationBuilder.create()\n  .usePlugin(new EmailPlugin({\n    host: 'smtp.gmail.com',\n    port: 587,\n    secure: false,\n    auth: {\n      user: process.env.EMAIL_USER!,\n      pass: process.env.EMAIL_PASS!\n    }\n  }))\n  .build();\n\n// Use in your code\nconst emailService = app.resolve('emailService');\nawait emailService.send(\n  'user@example.com',\n  'Welcome!',\n  '<h1>Welcome to our app!</h1>'\n);\n```\n\n## Publishing\n\n### 1. Package Structure\n\n```\nmy-plugin/\n├── src/\n│   ├── index.ts\n│   └── my-plugin.ts\n├── package.json\n├── tsconfig.json\n└── README.md\n```\n\n### 2. package.json\n\n```json\n{\n  \"name\": \"@myorg/stratix-plugin-email\",\n  \"version\": \"1.0.0\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"peerDependencies\": {\n    \"@stratix/core\": \"^0.1.0\"\n  }\n}\n```\n\n### 3. Export Plugin\n\n```typescript\n// src/index.ts\nexport { EmailPlugin } from './email.plugin';\nexport type { EmailConfig } from './email.plugin';\n```\n\n### 4. Publish to npm\n\n```bash\nnpm publish\n```\n\n## Best Practices\n\n### 1. Clear Naming\n\n```typescript\n// ✅ Good\nname: 'email'\nname: 'postgres'\nname: 'redis'\n\n// ❌ Bad\nname: 'plugin1'\nname: 'my-plugin'\n```\n\n### 2. Validate Configuration\n\n```typescript\nasync initialize(context: PluginContext): Promise<void> {\n  if (!this.config.host) {\n    throw new Error('Email host is required');\n  }\n}\n```\n\n### 3. Graceful Shutdown\n\n```typescript\nasync stop(): Promise<void> {\n  await this.connection?.close();\n  this.logger?.info('Plugin stopped');\n}\n```\n\n### 4. Comprehensive Health Checks\n\n```typescript\nasync healthCheck(): Promise<HealthCheckResult> {\n  const checks = await Promise.all([\n    this.checkConnection(),\n    this.checkDiskSpace(),\n    this.checkMemory()\n  ]);\n  \n  return {\n    status: checks.every(c => c.ok) ? 'healthy' : 'unhealthy',\n    details: checks\n  };\n}\n```\n\n## Next Steps\n\n- **[Plugin Architecture](./plugin-architecture)** - Architecture overview\n- **[Official Plugins](./official-plugins)** - Available plugins\n- **[Plugin Configuration](./plugin-configuration)** - Configuration guide\n",
      "metadata": {
        "type": "docs",
        "category": "plugins",
        "source": "docs/plugins/creating-plugins.md",
        "title": "Creating Plugins"
      }
    },
    {
      "id": "docs-plugins-official-plugins",
      "content": "\n# Official Plugins\n\nStratix provides official plugins for common infrastructure needs.\n\n## HTTP Servers\n\n### @stratix/http-fastify\n\nHigh-performance HTTP server using Fastify.\n\n```bash\nstratix add @stratix/http-fastify\n```\n\n**Features:**\n- Type-safe routes\n- CQRS integration\n- Error handling\n- Schema validation\n- CORS support\n\n### @stratix/http-express\n\nHTTP server using Express.\n\n```bash\nstratix add @stratix/http-express\n```\n\n## Databases\n\n### @stratix/postgres\n\nPostgreSQL database plugin.\n\n```bash\nstratix add @stratix/postgres\n```\n\n**Features:**\n- Connection pooling\n- Transaction support\n- Query builder\n- Migration support\n\n**[Documentation](../database/postgres)**\n\n### @stratix/mongodb\n\nMongoDB database plugin.\n\n```bash\nstratix add @stratix/mongodb\n```\n\n### @stratix/redis\n\nRedis caching and pub/sub.\n\n```bash\nstratix add @stratix/redis\n```\n\n## AI Providers\n\n### @stratix/ai-openai\n\nOpenAI integration (GPT-4, GPT-3.5).\n\n```bash\nstratix add @stratix/ai-openai\n```\n\n**Features:**\n- Chat completion\n- Streaming\n- Function calling\n- Embeddings\n- Cost tracking\n\n**[Documentation](../ai-agents/llm-providers)**\n\n### @stratix/ai-anthropic\n\nAnthropic Claude integration.\n\n```bash\nstratix add @stratix/ai-anthropic\n```\n\n## Message Queues\n\n### @stratix/rabbitmq\n\nRabbitMQ message broker.\n\n```bash\nstratix add @stratix/rabbitmq\n```\n\n## Dependency Injection\n\n### @stratix/di-awilix\n\nAwilix DI container (recommended).\n\n```bash\nstratix add @stratix/di-awilix\n```\n\n**[Documentation](../core-concepts/dependency-injection)**\n\n## Utilities\n\n### @stratix/logger\n\nStructured logging.\n\n```bash\nstratix add @stratix/logger\n```\n\n### @stratix/validation\n\nSchema validation.\n\n```bash\nstratix add @stratix/validation\n```\n\n### @stratix/cache\n\nCaching abstraction.\n\n```bash\nstratix add @stratix/cache\n```\n\n## Testing\n\n### @stratix/testing\n\nTesting utilities and mocks.\n\n```bash\nstratix add @stratix/testing --dev\n```\n\n**Features:**\n- MockLLMProvider\n- AgentTester\n- Test helpers\n\n**[Documentation](../ai-agents/agent-testing)**\n\n## Plugin Matrix\n\n| Plugin | Status | Version | Dependencies |\n|--------|--------|---------|--------------|\n| http-fastify | ✅ Stable | 0.1.3 | - |\n| http-express | ✅ Stable | 0.1.3 | - |\n| postgres | ✅ Stable | 0.1.3 | - |\n| mongodb | ✅ Stable | 0.1.3 | - |\n| redis | ✅ Stable | 0.1.3 | - |\n| ai-openai | ✅ Stable | 0.1.3 | - |\n| ai-anthropic | ✅ Stable | 0.1.3 | - |\n| rabbitmq | ✅ Stable | 0.1.3 | - |\n| di-awilix | ✅ Stable | 0.1.3 | - |\n| logger | ✅ Stable | 0.1.3 | - |\n| validation | ✅ Stable | 0.1.3 | - |\n| cache | ✅ Stable | 0.1.3 | - |\n| testing | ✅ Stable | 0.1.3 | - |\n\n## Next Steps\n\n- **[Creating Plugins](./creating-plugins)** - Build your own\n- **[Plugin Configuration](./plugin-configuration)** - Configuration guide\n- **[add Command](../cli/add-command)** - Install plugins\n",
      "metadata": {
        "type": "docs",
        "category": "plugins",
        "source": "docs/plugins/official-plugins.md",
        "title": "Official Plugins"
      }
    },
    {
      "id": "docs-plugins-plugin-architecture",
      "content": "\n# Plugin Architecture\n\nStratix uses a **plugin-based architecture** for extensibility and modularity.\n\n## Why Plugins?\n\n- ✅ **Modularity** - Add only what you need\n- ✅ **Extensibility** - Create custom plugins\n- ✅ **Dependency Management** - Automatic plugin ordering\n- ✅ **Lifecycle Management** - Initialize, start, stop hooks\n- ✅ **Type Safety** - Strongly typed plugin contracts\n\n## Plugin Interface\n\n```typescript\nimport { Plugin, PluginContext } from '@stratix/core';\n\nexport interface Plugin {\n  readonly metadata: PluginMetadata;\n  \n  initialize?(context: PluginContext): Promise<void>;\n  start?(context: PluginContext): Promise<void>;\n  stop?(): Promise<void>;\n  healthCheck?(): Promise<HealthCheckResult>;\n}\n```\n\n## Plugin Metadata\n\n```typescript\nexport interface PluginMetadata {\n  name: string;\n  version: string;\n  description?: string;\n  dependencies?: string[];\n  optionalDependencies?: string[];\n}\n```\n\n## Basic Plugin Example\n\n```typescript\nimport { Plugin, PluginContext } from '@stratix/core';\n\nexport class MyPlugin implements Plugin {\n  readonly metadata = {\n    name: 'my-plugin',\n    version: '1.0.0',\n    description: 'My custom plugin'\n  };\n\n  async initialize(context: PluginContext): Promise<void> {\n    console.log('Plugin initializing...');\n    \n    // Register services in container\n    context.container.register('myService', () => new MyService());\n  }\n\n  async start(context: PluginContext): Promise<void> {\n    console.log('Plugin starting...');\n  }\n\n  async stop(): Promise<void> {\n    console.log('Plugin stopping...');\n  }\n\n  async healthCheck(): Promise<HealthCheckResult> {\n    return {\n      status: 'healthy',\n      details: { uptime: process.uptime() }\n    };\n  }\n}\n```\n\n## Plugin Lifecycle\n\n```mermaid\ngraph LR\n    A[Register] --> B[Initialize]\n    B --> C[Start]\n    C --> D[Running]\n    D --> E[Stop]\n    \n    style A fill:#4CAF50\n    style B fill:#2196F3\n    style C fill:#FF9800\n    style D fill:#9C27B0\n    style E fill:#F44336\n```\n\n### 1. Register\n\n```typescript\nconst app = await ApplicationBuilder.create()\n  .usePlugin(new MyPlugin())\n  .build();\n```\n\n### 2. Initialize\n\nCalled once during application startup:\n\n```typescript\nasync initialize(context: PluginContext): Promise<void> {\n  // Register services\n  context.container.register('service', () => new Service());\n  \n  // Load configuration\n  const config = context.getConfig<MyConfig>();\n  \n  // Set up resources\n  this.connection = await createConnection(config);\n}\n```\n\n### 3. Start\n\nCalled after all plugins are initialized:\n\n```typescript\nasync start(context: PluginContext): Promise<void> {\n  // Start servers\n  await this.server.listen(3000);\n  \n  // Subscribe to events\n  context.eventBus.subscribe('user.created', this.handleUserCreated);\n}\n```\n\n### 4. Stop\n\nCalled during graceful shutdown:\n\n```typescript\nasync stop(): Promise<void> {\n  // Close connections\n  await this.connection.close();\n  \n  // Stop servers\n  await this.server.close();\n}\n```\n\n## Plugin Dependencies\n\nPlugins can depend on other plugins:\n\n```typescript\nexport class DatabasePlugin implements Plugin {\n  readonly metadata = {\n    name: 'database',\n    version: '1.0.0',\n    dependencies: ['logger'] // Requires logger plugin\n  };\n}\n\nexport class CachePlugin implements Plugin {\n  readonly metadata = {\n    name: 'cache',\n    version: '1.0.0',\n    dependencies: ['database'], // Requires database plugin\n    optionalDependencies: ['logger'] // Optional logger\n  };\n}\n```\n\n**Initialization order:**\n1. `logger` (no dependencies)\n2. `database` (depends on logger)\n3. `cache` (depends on database)\n\n## Plugin Context\n\nThe `PluginContext` provides access to:\n\n```typescript\ninterface PluginContext {\n  container: Container;\n  logger: Logger;\n  eventBus: EventBus;\n  getConfig<T>(): T;\n}\n```\n\n### Container\n\nRegister and resolve services:\n\n```typescript\nasync initialize(context: PluginContext): Promise<void> {\n  context.container.register('database', () => new Database());\n  \n  const db = context.container.resolve('database');\n}\n```\n\n### Logger\n\nLog messages:\n\n```typescript\nasync start(context: PluginContext): Promise<void> {\n  context.logger.info('Plugin started');\n  context.logger.error('Error occurred', error);\n}\n```\n\n### Event Bus\n\nPublish and subscribe to events:\n\n```typescript\nasync start(context: PluginContext): Promise<void> {\n  context.eventBus.subscribe('user.created', async (event) => {\n    context.logger.info('User created', event);\n  });\n}\n```\n\n### Configuration\n\nGet plugin configuration:\n\n```typescript\nasync initialize(context: PluginContext): Promise<void> {\n  const config = context.getConfig<DatabaseConfig>();\n  this.connection = await connect(config);\n}\n```\n\n## Real-World Example: HTTP Plugin\n\n```typescript\nimport { Plugin, PluginContext } from '@stratix/core';\nimport Fastify, { FastifyInstance } from 'fastify';\n\nexport interface HTTPPluginConfig {\n  port: number;\n  host?: string;\n}\n\nexport class HTTPPlugin implements Plugin {\n  readonly metadata = {\n    name: 'http',\n    version: '1.0.0',\n    description: 'HTTP server plugin',\n    dependencies: ['logger']\n  };\n\n  private server?: FastifyInstance;\n\n  async initialize(context: PluginContext): Promise<void> {\n    const config = context.getConfig<HTTPPluginConfig>();\n    \n    this.server = Fastify({\n      logger: false // Use Stratix logger instead\n    });\n\n    // Register routes\n    this.server.get('/health', async () => ({\n      status: 'healthy'\n    }));\n\n    context.logger.info('HTTP plugin initialized');\n  }\n\n  async start(context: PluginContext): Promise<void> {\n    const config = context.getConfig<HTTPPluginConfig>();\n    \n    await this.server!.listen({\n      port: config.port,\n      host: config.host || '0.0.0.0'\n    });\n\n    context.logger.info(`HTTP server listening on port ${config.port}`);\n  }\n\n  async stop(): Promise<void> {\n    await this.server?.close();\n  }\n\n  async healthCheck(): Promise<HealthCheckResult> {\n    return {\n      status: this.server ? 'healthy' : 'unhealthy',\n      details: {\n        port: this.server?.server.address()\n      }\n    };\n  }\n}\n```\n\n## Best Practices\n\n### 1. Clear Metadata\n\n```typescript\nreadonly metadata = {\n  name: 'my-plugin',\n  version: '1.0.0',\n  description: 'What this plugin does'\n};\n```\n\n### 2. Declare Dependencies\n\n```typescript\nreadonly metadata = {\n  name: 'cache',\n  dependencies: ['database'],\n  optionalDependencies: ['logger']\n};\n```\n\n### 3. Graceful Shutdown\n\n```typescript\nasync stop(): Promise<void> {\n  await this.connection?.close();\n  await this.server?.close();\n}\n```\n\n### 4. Health Checks\n\n```typescript\nasync healthCheck(): Promise<HealthCheckResult> {\n  try {\n    await this.connection.ping();\n    return { status: 'healthy' };\n  } catch (error) {\n    return { status: 'unhealthy', error: error.message };\n  }\n}\n```\n\n## Next Steps\n\n- **[Creating Plugins](./creating-plugins)** - Build your own\n- **[Official Plugins](./official-plugins)** - Available plugins\n- **[Plugin Configuration](./plugin-configuration)** - Configuration guide\n",
      "metadata": {
        "type": "docs",
        "category": "plugins",
        "source": "docs/plugins/plugin-architecture.md",
        "title": "Plugin Architecture"
      }
    },
    {
      "id": "docs-plugins-plugin-configuration",
      "content": "\n# Plugin Configuration\n\nLearn how to configure plugins in your Stratix application.\n\n## Configuration Methods\n\n### 1. Constructor Configuration\n\nPass configuration directly to the plugin constructor:\n\n```typescript\nimport { ApplicationBuilder } from '@stratix/runtime';\nimport { FastifyHTTPPlugin } from '@stratix/http-fastify';\n\nconst app = await ApplicationBuilder.create()\n  .usePlugin(new FastifyHTTPPlugin({\n    port: 3000,\n    host: '0.0.0.0',\n    cors: {\n      origin: '*'\n    }\n  }))\n  .build();\n```\n\n### 2. Environment Variables\n\n```typescript\nconst app = await ApplicationBuilder.create()\n  .usePlugin(new PostgresPlugin({\n    host: process.env.DB_HOST || 'localhost',\n    port: parseInt(process.env.DB_PORT || '5432'),\n    database: process.env.DB_NAME!,\n    user: process.env.DB_USER!,\n    password: process.env.DB_PASSWORD!\n  }))\n  .build();\n```\n\n### 3. Configuration Files\n\n```typescript\n// config/database.ts\nexport const databaseConfig = {\n  host: 'localhost',\n  port: 5432,\n  database: 'myapp'\n};\n\n// src/main.ts\nimport { databaseConfig } from '../config/database';\n\nconst app = await ApplicationBuilder.create()\n  .usePlugin(new PostgresPlugin(databaseConfig))\n  .build();\n```\n\n## Plugin-Specific Configuration\n\n### HTTP Plugin\n\n```typescript\nnew FastifyHTTPPlugin({\n  port: 3000,\n  host: '0.0.0.0',\n  cors: {\n    origin: ['http://localhost:3000'],\n    credentials: true\n  },\n  rateLimit: {\n    max: 100,\n    timeWindow: '1 minute'\n  }\n})\n```\n\n### Database Plugin\n\n```typescript\nnew PostgresPlugin({\n  host: 'localhost',\n  port: 5432,\n  database: 'myapp',\n  user: 'postgres',\n  password: 'password',\n  pool: {\n    min: 2,\n    max: 10\n  },\n  ssl: process.env.NODE_ENV === 'production'\n})\n```\n\n### AI Provider Plugin\n\n```typescript\nnew OpenAIProvider({\n  apiKey: process.env.OPENAI_API_KEY!,\n  organization: 'org-123',\n  defaultModel: 'gpt-4o',\n  timeout: 30000,\n  maxRetries: 3\n})\n```\n\n## Best Practices\n\n### 1. Use Environment Variables\n\n```typescript\n// ✅ Good\nport: parseInt(process.env.PORT || '3000')\n\n// ❌ Bad\nport: 3000\n```\n\n### 2. Validate Configuration\n\n```typescript\nconst port = parseInt(process.env.PORT || '3000');\nif (port < 1 || port > 65535) {\n  throw new Error('Invalid port number');\n}\n```\n\n### 3. Provide Defaults\n\n```typescript\nconst config = {\n  host: process.env.DB_HOST || 'localhost',\n  port: parseInt(process.env.DB_PORT || '5432'),\n  pool: {\n    min: 2,\n    max: 10\n  }\n};\n```\n\n### 4. Separate by Environment\n\n```typescript\n// config/production.ts\nexport const config = {\n  database: {\n    ssl: true,\n    pool: { max: 20 }\n  }\n};\n\n// config/development.ts\nexport const config = {\n  database: {\n    ssl: false,\n    pool: { max: 5 }\n  }\n};\n```\n\n## Next Steps\n\n- **[Plugin Architecture](./plugin-architecture)** - Architecture overview\n- **[Creating Plugins](./creating-plugins)** - Build plugins\n- **[Official Plugins](./official-plugins)** - Available plugins\n",
      "metadata": {
        "type": "docs",
        "category": "plugins",
        "source": "docs/plugins/plugin-configuration.md",
        "title": "Plugin Configuration"
      }
    },
    {
      "id": "docs-stratix-copilot-commands",
      "content": "\n# Commands Reference\n\nComplete reference of all Stratix Copilot commands and features.\n\n## Chat Commands\n\n### Entity Generation\n\n**Command:** `/entity`\n\n**Syntax:**\n```\n@stratix /entity <EntityName> with <prop1>, <prop2>, ...\n```\n\n**Examples:**\n```\n@stratix /entity User with email, name, createdAt\n@stratix /entity Product with name, price, stock, category\n@stratix /entity Order with orderId, customerId, items, total\n```\n\n**Generates:**\n- Entity class extending `Entity<Props>`\n- Props interface\n- Private constructor\n- Static `create()` factory method\n- Getters for all properties\n- Proper TypeScript types\n\n---\n\n### Command Generation\n\n**Command:** `/command`\n\n**Syntax:**\n```\n@stratix /command <CommandName> with <param1>, <param2>, ...\n```\n\n**Examples:**\n```\n@stratix /command CreateUser with userId, email, name\n@stratix /command UpdateProduct with productId, price\n@stratix /command DeleteOrder with orderId\n```\n\n**Generates:**\n- Command DTO class\n- Command handler implementing `ICommandHandler`\n- Repository injection\n- Result pattern usage\n- Error handling\n\n---\n\n### Query Generation\n\n**Command:** `/query`\n\n**Syntax:**\n```\n@stratix /query <QueryName> with <param1>, <param2>, ...\n```\n\n**Examples:**\n```\n@stratix /query GetUserById with userId\n@stratix /query ListProducts with page, limit\n@stratix /query SearchOrders with status, dateFrom, dateTo\n```\n\n**Generates:**\n- Query DTO class\n- Query handler implementing `IQueryHandler`\n- Repository usage\n- Result pattern for responses\n- Proper typing\n\n---\n\n### Value Object Generation\n\n**Command:** `/vo`\n\n**Syntax:**\n```\n@stratix /vo <ValueObjectName> [with validation]\n```\n\n**Examples:**\n```\n@stratix /vo Email with validation\n@stratix /vo Money with currency\n@stratix /vo Address with street, city, zipCode\n```\n\n**Generates:**\n- Value object class extending `ValueObject<Props>`\n- Props interface\n- Validation logic\n- Static `create()` returning `Result<VO>`\n- Equality methods (`equals()`)\n\n---\n\n### Repository Generation\n\n**Command:** `/repository`\n\n**Syntax:**\n```\n@stratix /repository <RepositoryName>\n```\n\n**Examples:**\n```\n@stratix /repository UserRepository\n@stratix /repository ProductRepository with PostgreSQL\n@stratix /repository OrderRepository\n```\n\n**Generates:**\n- Repository interface\n- Method signatures (findById, save, delete, etc.)\n- Optional implementation (in-memory, PostgreSQL, MongoDB)\n- Proper typing with generics\n\n---\n\n### Bounded Context Generation\n\n**Command:** `/context`\n\n**Syntax:**\n```\n@stratix /context <ContextName>\n```\n\n**Examples:**\n```\n@stratix /context Orders\n@stratix /context Users\n@stratix /context Inventory\n```\n\n**Generates:**\n- Complete folder structure\n- Sample entity\n- Sample repository\n- Sample commands and queries\n- Infrastructure setup\n- Index file with exports\n\n---\n\n### Refactoring Suggestions\n\n**Command:** `/refactor`\n\n**Syntax:**\n```\n@stratix /refactor\n[paste your code]\n```\n\n**Examples:**\n```\n@stratix /refactor\nclass User {\n  constructor(public name: string, public email: string) {}\n}\n```\n\n**Provides:**\n- DDD pattern suggestions\n- Value object opportunities\n- Entity improvements\n- CQRS recommendations\n- Code organization tips\n\n---\n\n### Concept Explanation\n\n**Command:** `/explain`\n\n**Syntax:**\n```\n@stratix /explain <concept>\n```\n\n**Examples:**\n```\n@stratix /explain aggregate roots\n@stratix /explain Result pattern\n@stratix /explain dependency injection\n@stratix /explain bounded contexts\n```\n\n**Provides:**\n- Clear definition\n- Code examples from Stratix\n- When to use it\n- Best practices\n- Related concepts\n\n---\n\n## VS Code Commands\n\nAccess via Command Palette (`Cmd+Shift+P`):\n\n### Stratix: Open AI Assistant\n\nOpens Copilot Chat with Stratix context.\n\n**Shortcut:** None (use Command Palette)\n\n---\n\n### Stratix: Rebuild Knowledge Base\n\nRebuilds the knowledge base from documentation sources.\n\n**When to use:**\n- After Stratix framework update\n- KB seems outdated\n- Troubleshooting issues\n\n**Process:**\n1. Scans all documentation\n2. Generates embeddings\n3. Saves to storage\n4. Shows completion message\n\n**Duration:** ~30 seconds\n\n---\n\n### Stratix: Show Knowledge Base Info\n\nDisplays knowledge base version and statistics.\n\n**Shows:**\n- KB version (matches Stratix version)\n- Generation date\n- Total documents\n- Documents by type:\n  - Docusaurus docs\n  - Package READMEs\n  - Patterns\n  - Examples\n\n---\n\n## General Chat\n\nYou can also ask general questions without slash commands:\n\n```\n@stratix how do I implement a repository?\n@stratix what's the difference between commands and queries?\n@stratix show me an example of an aggregate root\n@stratix how do I use the Result pattern?\n```\n\nStratix Copilot will:\n- Search knowledge base\n- Retrieve relevant documentation\n- Provide code examples\n- Show source references\n\n---\n\n## Tips\n\n### Command Modifiers\n\nAdd details to get more specific results:\n\n```\n@stratix /entity User with email validation\n@stratix /command CreateOrder with transaction support\n@stratix /repository UserRepository with caching\n```\n\n### Follow-up Questions\n\nRefine generated code with follow-ups:\n\n```\n@stratix add validation to the email property\n@stratix make the price property required\n@stratix add a method to calculate total\n```\n\n### Context Awareness\n\nStratix Copilot understands your project:\n\n```\n@stratix /entity Order\n# Knows about existing User, Product entities\n# Generates proper relationships\n```\n\n---\n\n## Next Steps\n\n- [Examples](./examples.md) - Real-world usage examples\n- [Troubleshooting](./troubleshooting.md) - Common issues\n- [Best Practices](./best-practices.md) - Tips for effective use\n",
      "metadata": {
        "type": "docs",
        "category": "stratix-copilot",
        "source": "docs/stratix-copilot/commands.md",
        "title": "commands"
      }
    },
    {
      "id": "docs-stratix-copilot-installation",
      "content": "\n# Installation\n\nInstall Stratix Copilot to enhance your Stratix development experience with AI-powered code generation.\n\n## Prerequisites\n\nBefore installing Stratix Copilot, ensure you have:\n\n- **VS Code** 1.85.0 or higher\n- **GitHub Copilot** subscription and extension installed\n- **Stratix project** (or create one with `npx @stratix/cli new`)\n\n## Installation Methods\n\n### Method 1: VS Code Marketplace (Recommended)\n\n> [!NOTE]\n> Coming soon! The extension will be published to the VS Code Marketplace.\n\n1. Open VS Code\n2. Go to Extensions (`Cmd+Shift+X`)\n3. Search for \"Stratix Copilot\"\n4. Click **Install**\n\n### Method 2: From Source (Development)\n\nFor development or early access:\n\n```bash\n# Clone the Stratix repository\ngit clone https://github.com/stratix-dev/stratix.git\ncd stratix\n\n# Install dependencies\npnpm install\n\n# Build the extension\ncd packages/copilot-rag\npnpm run compile\n\n# Package the extension\npnpm run package\n```\n\nThen install the `.vsix` file:\n\n1. Open VS Code\n2. `Cmd+Shift+P` → `Extensions: Install from VSIX...`\n3. Select `stratix-copilot-*.vsix`\n\n## Verify Installation\n\nAfter installation, verify Stratix Copilot is working:\n\n1. **Check Output Panel**\n   - Open Output panel (`Cmd+Shift+U`)\n   - Select \"Stratix AI Assistant\" from dropdown\n   - You should see:\n     ```\n     Stratix AI Assistant activating...\n     Knowledge base initialized with 36 documents\n     KB Version: 0.1.3\n     🎉 Stratix AI Assistant activated successfully!\n     ```\n\n2. **Test in Copilot Chat**\n   - Open Copilot Chat (`Cmd+Shift+I`)\n   - Type `@stratix hello`\n   - You should get a response about Stratix\n\n3. **Check Commands**\n   - `Cmd+Shift+P` → Type \"Stratix\"\n   - You should see:\n     - `Stratix: Open AI Assistant`\n     - `Stratix: Rebuild Knowledge Base`\n     - `Stratix: Show Knowledge Base Info`\n\n## First-Time Setup\n\n### 1. Initialize Knowledge Base\n\nThe first time you use Stratix Copilot, it will:\n\n- Download the embedding model (~90MB)\n- Generate embeddings for 36 documents\n- Save to local storage for fast future loads\n\nThis takes **1-2 minutes** on first run. Subsequent loads are instant.\n\n### 2. Configure (Optional)\n\nStratix Copilot works out of the box, but you can customize:\n\n**VS Code Settings** (`settings.json`):\n\n```json\n{\n  \"stratix.copilot.enabled\": true,\n  \"stratix.copilot.autoUpdate\": true\n}\n```\n\n## Troubleshooting\n\n### Extension Not Activating\n\n**Problem**: Extension doesn't appear in Output panel\n\n**Solution**:\n1. Check VS Code version: `Code → About Visual Studio Code`\n2. Ensure GitHub Copilot is installed and activated\n3. Reload window: `Cmd+Shift+P` → `Developer: Reload Window`\n\n### Knowledge Base Not Loading\n\n**Problem**: Shows \"0 documents\" or errors in Output\n\n**Solution**:\n```bash\n# Rebuild knowledge base\nCmd+Shift+P → \"Stratix: Rebuild Knowledge Base\"\n```\n\n### Slow First Load\n\n**Problem**: Takes long time on first activation\n\n**Expected**: First load downloads embedding model (~90MB) and generates embeddings. This is normal and only happens once.\n\n**Solution**: Wait for completion. Subsequent loads will be instant.\n\n### Chat Not Responding\n\n**Problem**: `@stratix` doesn't work in Copilot Chat\n\n**Solution**:\n1. Verify GitHub Copilot is active\n2. Check Output panel for errors\n3. Try reloading window\n4. Ensure you're using `@stratix` (with @)\n\n## Updating\n\n### Automatic Updates (Marketplace)\n\nWhen published to Marketplace, VS Code will auto-update the extension.\n\n### Manual Updates (From Source)\n\n```bash\ncd stratix/packages/copilot-rag\ngit pull\npnpm run compile\npnpm run package\n# Install new .vsix file\n```\n\n### Update Knowledge Base\n\nThe knowledge base auto-updates, but you can manually update:\n\n```bash\nCmd+Shift+P → \"Stratix: Rebuild Knowledge Base\"\n```\n\n## Uninstallation\n\nTo remove Stratix Copilot:\n\n1. Open Extensions (`Cmd+Shift+X`)\n2. Find \"Stratix Copilot\"\n3. Click **Uninstall**\n\nThis removes:\n- Extension files\n- Knowledge base storage\n- All settings\n\n## Next Steps\n\n- [Usage Guide](./usage.md) - Learn how to use Stratix Copilot\n- [Commands Reference](./commands.md) - Complete command list\n- [Examples](./examples.md) - Real-world usage examples\n",
      "metadata": {
        "type": "docs",
        "category": "stratix-copilot",
        "source": "docs/stratix-copilot/installation.md",
        "title": "installation"
      }
    },
    {
      "id": "docs-stratix-copilot-overview",
      "content": "\n# Stratix Copilot\n\n**AI-powered coding assistant for Stratix framework with intelligent code generation and context-aware suggestions.**\n\nStratix Copilot is a VS Code extension that enhances GitHub Copilot with deep knowledge of the Stratix framework, enabling you to generate DDD/CQRS code that follows best practices automatically.\n\n## What is Stratix Copilot?\n\nStratix Copilot is an intelligent VS Code extension that integrates with GitHub Copilot Chat to provide:\n\n- **Context-Aware AI** - Understands your project structure (DDD/Modular)\n- **Framework Knowledge** - Trained on complete Stratix documentation\n- **Smart Code Generation** - Generates entities, commands, queries, value objects\n- **Auto-Updates** - Knowledge base stays synchronized with framework updates\n- **RAG-Enhanced** - Retrieves relevant documentation for accurate responses\n\n## Key Features\n\n### RAG-Enhanced Responses\n\nStratix Copilot uses **Retrieval Augmented Generation (RAG)** to provide accurate, framework-specific responses:\n\n- Searches 36+ documentation sources\n- Retrieves relevant patterns and examples\n- Generates code following exact Stratix conventions\n- Shows source references for transparency\n\n### Slash Commands\n\nQuick access to common code generation tasks:\n\n| Command | Description |\n|---------|-------------|\n| `/entity` | Generate a domain entity with props and methods |\n| `/command` | Generate a CQRS command with handler |\n| `/query` | Generate a CQRS query with handler |\n| `/vo` | Generate a value object with validation |\n| `/repository` | Generate repository interface |\n| `/context` | Generate complete bounded context |\n| `/refactor` | Get refactoring suggestions for DDD patterns |\n| `/explain` | Explain Stratix concepts with examples |\n\n### Code Generation\n\nStratix Copilot generates complete, production-ready code following DDD patterns:\n\n- **Entities** - With proper encapsulation and factory methods\n- **Commands & Queries** - Following CQRS patterns with handlers\n- **Value Objects** - With validation and equality methods\n- **Repositories** - Interface and implementation examples\n\n### Automatic Knowledge Updates\n\nThe knowledge base is automatically updated when Stratix documentation changes:\n\n- **Version Tracking** - KB version matches framework version\n- **CI/CD Integration** - Auto-updates via GitHub Actions\n- **Manual Updates** - `Stratix: Rebuild Knowledge Base` command\n\n## How It Works\n\n```mermaid\ngraph LR\n    A[You ask in Chat] --> B[Stratix Copilot]\n    B --> C[Analyze Project]\n    B --> D[Search Knowledge Base]\n    D --> E[36+ Docs]\n    C --> F[Build Context]\n    D --> F\n    F --> G[GitHub Copilot]\n    G --> H[Generate Code]\n    H --> I[Show in Chat]\n    I --> J[Copy & Use]\n```\n\n1. **You ask** in GitHub Copilot Chat with `@stratix`\n2. **Analyzes** your project structure and existing code\n3. **Searches** knowledge base for relevant documentation\n4. **Enriches** the prompt with Stratix patterns and examples\n5. **Generates** code using GitHub Copilot's LLM\n6. **Shows** generated code in chat with explanations\n7. **Copy and paste** the code into your project files\n\n## Example Usage\n\n### Generate an Entity\n\n```\n@stratix /entity Product with name, price, and category\n```\n\n**Result:**\n- Generates complete `Product` entity following Stratix patterns\n- Shows code in chat with explanations\n- Copy and save to `src/domain/entities/Product.ts`\n\n### Generate a Command\n\n```\n@stratix /command CreateProduct with productId, name, price\n```\n\n**Result:**\n- Generates command DTO and handler\n- Follows CQRS patterns\n- Includes proper imports and types\n- Ready to copy into your project\n\n### Ask Questions\n\n```\n@stratix how do I implement a repository with PostgreSQL?\n```\n\n**Result:**\n- Retrieves relevant documentation\n- Shows code examples\n- Explains step-by-step\n- Includes source references\n\n## Requirements\n\n- **VS Code** 1.85.0 or higher\n- **GitHub Copilot** subscription\n- **Node.js** 18.0.0 or higher (for development)\n\n## Next Steps\n\n- [Installation](./installation.md) - Install Stratix Copilot\n- [Usage Guide](./usage.md) - Learn how to use all features\n- [Commands Reference](./commands.md) - Complete command list\n\n## Version Information\n\nCurrent Knowledge Base:\n- **Version**: Matches Stratix framework version\n- **Documents**: 36+ indexed sources\n- **Auto-Updates**: Weekly + on documentation changes\n\nCheck your KB version: `Cmd+Shift+P` → `Stratix: Show Knowledge Base Info`\n",
      "metadata": {
        "type": "docs",
        "category": "stratix-copilot",
        "source": "docs/stratix-copilot/overview.md",
        "title": "overview"
      }
    },
    {
      "id": "docs-stratix-copilot-usage",
      "content": "\n# Usage Guide\n\nLearn how to use Stratix Copilot to accelerate your Stratix development with AI-powered code generation.\n\n## Basic Usage\n\n### Opening Stratix Copilot\n\n**Method 1: Command Palette**\n```\nCmd+Shift+P → \"Stratix: Open AI Assistant\"\n```\n\n**Method 2: Copilot Chat**\n```\nCmd+Shift+I (open Copilot Chat)\nType: @stratix\n```\n\n### Asking Questions\n\nSimply type `@stratix` followed by your question:\n\n```\n@stratix how do I create an entity?\n@stratix explain the Result pattern\n@stratix show me a CQRS command example\n```\n\n## Slash Commands\n\nStratix Copilot provides specialized commands for common tasks:\n\n### `/entity` - Generate Entity\n\nGenerate a domain entity with properties and methods:\n\n```\n@stratix /entity User with email, name, and createdAt\n```\n\n**Generated:**\n- Complete entity class extending `Entity`\n- Props interface\n- Private constructor\n- Static `create()` method\n- Getters for all properties\n- Proper imports from `@stratix/core`\n\n---\n\n### `/command` - Generate Command\n\nGenerate a CQRS command with handler:\n\n```\n@stratix /command CreateUser with userId, email, name\n```\n\n**Generated:**\n- Command DTO class\n- Command handler class\n- Proper CQRS structure\n- Repository injection\n- Error handling with Result pattern\n\n---\n\n### `/query` - Generate Query\n\nGenerate a CQRS query with handler:\n\n```\n@stratix /query GetUserById with userId\n```\n\n**Generated:**\n- Query DTO class\n- Query handler class\n- Repository usage\n- Result pattern for responses\n\n---\n\n### `/vo` - Generate Value Object\n\nGenerate a value object with validation:\n\n```\n@stratix /vo Email with validation\n```\n\n**Generated:**\n- Value object class extending `ValueObject`\n- Props interface\n- Validation logic\n- Static `create()` returning `Result<Email>`\n- Equality methods\n\n---\n\n### `/repository` - Generate Repository\n\nGenerate repository interface and implementation:\n\n```\n@stratix /repository UserRepository\n```\n\n**Generated:**\n- Repository interface\n- Method signatures (findById, save, delete)\n- Optional in-memory implementation\n\n---\n\n### `/context` - Generate Bounded Context\n\nGenerate a complete bounded context structure:\n\n```\n@stratix /context Orders\n```\n\n**Generated:**\n- Complete folder structure\n- Entity, repository, commands, queries\n- Infrastructure setup\n- Index file with exports\n\n---\n\n### `/refactor` - Get Refactoring Suggestions\n\nAnalyze code and suggest DDD improvements:\n\n```\n@stratix /refactor [paste your code]\n```\n\n**Provides:**\n- DDD pattern suggestions\n- Value object opportunities\n- CQRS improvements\n- Code organization tips\n\n---\n\n### `/explain` - Explain Concepts\n\nGet detailed explanations with examples:\n\n```\n@stratix /explain aggregate roots\n@stratix /explain dependency injection\n```\n\n**Provides:**\n- Clear definition\n- Code examples from Stratix\n- When to use it\n- Best practices\n\n## Working with Generated Code\n\nAfter generating code, follow these steps:\n\n1. **Review Generated Code** in chat\n2. **Copy the code** from the chat response\n3. **Create file** in the correct location\n4. **Paste and save** the code\n\n### Recommended File Locations\n\nStratix Copilot provides code that follows these conventions:\n\n**DDD Structure:**\n```\nsrc/\n├── domain/\n│   ├── entities/          ← Entities\n│   ├── value-objects/     ← Value Objects\n│   └── repositories/      ← Repository interfaces\n├── application/\n│   ├── commands/          ← Commands & handlers\n│   └── queries/           ← Queries & handlers\n└── infrastructure/\n    └── repositories/      ← Repository implementations\n```\n\n**Modular Structure:**\n```\nsrc/contexts/{context}/\n├── domain/\n│   ├── entities/\n│   ├── value-objects/\n│   └── repositories/\n├── application/\n│   ├── commands/\n│   └── queries/\n└── infrastructure/\n    └── repositories/\n```\n\n## Advanced Usage\n\n### Context-Aware Generation\n\nStratix Copilot analyzes your project:\n\n```\n@stratix /entity Order\n```\n\n**Copilot knows:**\n- Your project structure (DDD/Modular)\n- Existing entities (User, Product, etc.)\n- Installed Stratix packages\n- Whether you have stratix.config.js\n\n**Result:** Generated code matches your project conventions.\n\n### Multi-Step Workflows\n\nCombine commands for complete features:\n\n```\n1. @stratix /entity Product with name, price, stock\n2. @stratix /vo Money for price with currency\n3. @stratix /command CreateProduct\n4. @stratix /query GetProductById\n5. @stratix /repository ProductRepository\n```\n\n### Code Refinement\n\nAsk follow-up questions to refine generated code:\n\n```\n@stratix add validation to ensure price is positive\n@stratix add a method to check if product is in stock\n@stratix add timestamps to the entity\n```\n\n## Knowledge Base Management\n\n### View KB Information\n\n```\nCmd+Shift+P → \"Stratix: Show Knowledge Base Info\"\n```\n\nShows:\n- KB version\n- Document count\n- Generation date\n- Statistics by type\n\n### Rebuild Knowledge Base\n\n```\nCmd+Shift+P → \"Stratix: Rebuild Knowledge Base\"\n```\n\nUse when:\n- KB seems outdated\n- After Stratix framework update\n- Troubleshooting issues\n\n## Tips & Best Practices\n\n### 1. Be Specific\n\n❌ Bad: `@stratix create entity`\n✅ Good: `@stratix /entity Product with name, price, and category`\n\n### 2. Use Slash Commands\n\nSlash commands provide better context and more accurate results.\n\n### 3. Review Generated Code\n\nAlways review generated code before saving. Stratix Copilot is smart but not perfect.\n\n### 4. Iterate\n\nDon't hesitate to ask follow-up questions to refine the code.\n\n### 5. Check References\n\nCopilot shows source references - review them for deeper understanding.\n\n## Keyboard Shortcuts\n\n| Action | Shortcut |\n|--------|----------|\n| Open Copilot Chat | `Cmd+Shift+I` |\n| Open Command Palette | `Cmd+Shift+P` |\n| Open Stratix Assistant | `Cmd+Shift+P` → \"Stratix: Open\" |\n\n## Next Steps\n\n- [Commands Reference](./commands.md) - Complete command list\n- [Examples](./examples.md) - Real-world usage examples\n- [Troubleshooting](./troubleshooting.md) - Common issues and solutions\n",
      "metadata": {
        "type": "docs",
        "category": "stratix-copilot",
        "source": "docs/stratix-copilot/usage.md",
        "title": "usage"
      }
    },
    {
      "id": "package-cli",
      "content": "# @stratix/cli\n\nGlobal CLI for Stratix framework - Create projects and generate code with powerful generators.\n\n## Installation\n\n```bash\nnpm install -g @stratix/cli\n```\n\n## Quick Start\n\n```bash\n# Create a new project\nstratix new my-app\n\n# Generate a bounded context\ncd my-app\nstratix generate context Products --props '[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"number\"},{\"name\":\"stock\",\"type\":\"number\"}]'\n```\n\n## Commands\n\n### `stratix new [project-name]`\n\nCreate a new Stratix project with minimal setup.\n\n**Options:**\n- `--pm <manager>` - Package manager (npm, pnpm, yarn)\n- `--structure <type>` - Project structure (ddd, modular) - default: ddd\n- `--no-git` - Skip git initialization\n- `--skip-install` - Skip dependency installation\n\n**Examples:**\n```bash\n# Interactive mode (prompts for options)\nstratix new\n\n# With project name\nstratix new my-app\n\n# With options\nstratix new my-app --pm pnpm --structure ddd\nstratix new my-app --no-git --skip-install\n```\n\n### `stratix generate <type> <name>`\n\nAlias: `stratix g`\n\nGenerate code artifacts using built-in generators.\n\n**Common Options:**\n- `--dry-run` - Preview generated files without writing\n- `--force` - Overwrite existing files\n\n#### Available Generators\n\n##### `entity <name>` - Domain Entity\nGenerates a domain entity or aggregate root.\n\n**Options:**\n- `--props <props>` - Entity properties as JSON array\n- `--aggregate` - Generate as AggregateRoot (default: true)\n- `--dry-run` - Preview generated files without writing\n- `--force` - Overwrite existing files\n\n**Example:**\n```bash\nstratix g entity Product --props '[{\"name\":\"id\",\"type\":\"string\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"number\"}]'\n```\n\n##### `value-object <name>` (alias: `vo`)\nGenerates a domain value object.\n\n**Options:**\n- `--props <props>` - Value object properties as JSON array\n- `--dry-run` - Preview generated files without writing\n\n**Example:**\n```bash\nstratix g value-object Email --props '[{\"name\":\"value\",\"type\":\"string\"}]'\nstratix g vo Address --props '[{\"name\":\"street\",\"type\":\"string\"},{\"name\":\"city\",\"type\":\"string\"}]'\n```\n\n##### `command <name>` - CQRS Command\nGenerates a command with its handler.\n\n**Options:**\n- `--props <props>` - Input properties as JSON array\n- `--no-handler` - Skip handler generation\n- `--dry-run` - Preview generated files without writing\n\n**Example:**\n```bash\nstratix g command CreateProduct --props '[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"number\"}]'\n```\n\n##### `query <name>` - CQRS Query\nGenerates a query with its handler.\n\n**Options:**\n- `--props <props>` - Input properties as JSON array\n- `--return-type <type>` - Return type for the query (default: \"any\")\n- `--no-handler` - Skip handler generation\n- `--dry-run` - Preview generated files without writing\n\n**Example:**\n```bash\nstratix g query GetProductById --props '[{\"name\":\"id\",\"type\":\"string\"}]' --return-type \"Product\"\nstratix g query ListProducts --return-type \"Product[]\"\n```\n\n##### `repository <entityName>` (alias: `repo`)\nGenerates a repository interface and implementation.\n\n**Options:**\n- `--no-implementation` - Generate only the interface\n- `--dry-run` - Preview generated files without writing\n\n**Example:**\n```bash\nstratix g repository Product\nstratix g repo Order --no-implementation\n```\n\n##### `quality` - Quality Configuration\nGenerates quality configuration files (Prettier, ESLint, EditorConfig, .gitignore).\n\n**Options:**\n- `--no-prettier` - Skip Prettier config\n- `--no-eslint` - Skip ESLint config\n- `--no-editorconfig` - Skip EditorConfig\n- `--no-gitignore` - Skip .gitignore\n- `--dry-run` - Preview generated files without writing\n\n**Example:**\n```bash\nstratix g quality\nstratix g quality --no-gitignore\n```\n\n### `stratix add <extension>`\n\nInstall Stratix extensions to your project with automatic dependency resolution.\n\n**Examples:**\n```bash\n# Install HTTP extension\nstratix add http\n\n# Install database extensions\nstratix add postgres\nstratix add mongodb\nstratix add redis\n\n# Install AI providers\nstratix add ai-openai\nstratix add ai-anthropic\n\n# List all available extensions\nstratix add list\n```\n\n**Available Extensions (13):**\n\n**Production Extensions:**\n- `http` - Fastify HTTP server integration\n- `validation` - Zod-based schema validation\n- `mappers` - Entity-to-DTO mapping utilities\n- `auth` - JWT authentication and RBAC authorization\n- `errors` - Structured error handling\n\n**Data & Infrastructure:**\n- `postgres` - PostgreSQL database integration\n- `mongodb` - MongoDB database integration\n- `redis` - Redis caching and session store\n- `rabbitmq` - RabbitMQ message broker\n- `opentelemetry` - Observability (traces, metrics, logs)\n- `secrets` - Secrets management\n\n**AI Providers:**\n- `ai-openai` - OpenAI LLM provider\n- `ai-anthropic` - Anthropic Claude provider\n\n**Note:** The command automatically detects your package manager (npm/pnpm/yarn) and installs the extension with its peer dependencies.\n\n### `stratix info`\n\nDisplay project information including installed Stratix packages, environment details, and quick reference commands.\n\n**Example output:**\n```\nProject Information\n\nProject:\n  Name:    my-app\n  Version: 0.1.0\n\nEnvironment:\n  Package Manager: pnpm\n  Project Structure: DDD/Hexagonal\n  Node Version: v20.10.0\n\nStratix Packages:\n  @stratix/core@0.1.3\n  @stratix/runtime@0.1.3\n  @stratix/http-fastify@0.1.3\n\nQuick Commands:\n  stratix g context <name>    - Generate bounded context\n  stratix g entity <name>     - Generate entity\n  stratix add <extension>     - Install extension\n  stratix add list            - List available extensions\n```\n\n## Full Workflow Example\n\n```bash\n# 1. Create new project\nstratix new my-ecommerce --pm pnpm\n\n# 2. Navigate to project\ncd my-ecommerce\n\n# 3. Add extensions you need\nstratix add http\nstratix add postgres\nstratix add validation\n\n# 4. Generate bounded contexts and artifacts\nstratix g entity Product --props '[{\"name\":\"id\",\"type\":\"string\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"number\"}]'\nstratix g entity Customer --props '[{\"name\":\"email\",\"type\":\"string\"},{\"name\":\"name\",\"type\":\"string\"}]'\nstratix g value-object Money --props '[{\"name\":\"amount\",\"type\":\"number\"},{\"name\":\"currency\",\"type\":\"string\"}]'\nstratix g command CreateOrder --props '[{\"name\":\"customerId\",\"type\":\"string\"},{\"name\":\"items\",\"type\":\"OrderItem[]\"}]'\nstratix g query GetOrdersByCustomer --props '[{\"name\":\"customerId\",\"type\":\"string\"}]' --return-type \"Order[]\"\n\n# 5. Build and run (using standard npm scripts)\npnpm install\npnpm build\npnpm start\n```\n\n## Features\n\n- ✨ **Quick Project Setup** - Create production-ready projects in seconds\n- 🔨 **6 Code Generators** - Generate entities, commands, queries, repositories, value objects, and quality configs\n- 📦 **Extension Manager** - Install 13 Stratix extensions with automatic dependency resolution\n- 🎯 **Interactive Mode** - Smart prompts guide you through project creation\n- ⚙️ **Flexible Options** - CLI flags or interactive prompts, your choice\n- 📊 **Project Info** - Instant overview of your Stratix project\n- 🏗️ **DDD & CQRS** - Follows Domain-Driven Design and CQRS patterns\n- 🔒 **Type-Safe** - Full TypeScript support with strict typing\n\n## Requirements\n\n- Node.js >= 18.0.0\n- npm, pnpm, or yarn\n\n## Learn More\n\n- [Stratix Documentation](https://stratix.dev/docs)\n- [CLI Reference](https://stratix.dev/docs/cli/overview)\n- [GitHub Repository](https://github.com/stratix-dev/stratix)\n\n## Contributing\n\nContributions are welcome! Please read our contributing guidelines before submitting PRs.\n\n## License\n\nMIT - Copyright (c) 2025 P. Andrés Carvajal\n",
      "metadata": {
        "type": "api",
        "category": "packages",
        "source": "packages/cli/README.md",
        "title": "@stratix/cli"
      }
    },
    {
      "id": "package-copilot-rag",
      "content": "# Stratix Copilot\n\n**AI-powered coding assistant for Stratix framework** - Generate DDD/CQRS code with intelligent, context-aware suggestions.\n\n[![VS Code](https://img.shields.io/badge/VS%20Code-1.85%2B-blue)](https://code.visualstudio.com/)\n[![GitHub Copilot](https://img.shields.io/badge/GitHub%20Copilot-Required-green)](https://github.com/features/copilot)\n[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)\n\n## What is Stratix Copilot?\n\nStratix Copilot is a VS Code extension that enhances GitHub Copilot with deep knowledge of the Stratix framework. It uses **Retrieval Augmented Generation (RAG)** to provide accurate, framework-specific code generation.\n\n### Key Features\n\n- **Context-Aware AI** - Understands your project structure (DDD/Modular)\n- **Framework Knowledge** - Trained on 36+ Stratix documentation sources\n- **Smart Code Generation** - Entities, commands, queries, value objects\n- **Auto-Updates** - Knowledge base stays synchronized with framework\n- **RAG-Enhanced** - Retrieves relevant documentation for accurate responses\n- **Privacy-First** - All processing happens locally\n- **No API Keys** - Uses your existing GitHub Copilot subscription\n\n### Usage\n\nOpen Copilot Chat and use `@stratix`:\n\n```\n@stratix /entity Product with name, price, stock\n@stratix /command CreateProduct with productId, name, price\n@stratix /query GetProductById with productId\n@stratix /vo Email with validation\n@stratix how do I implement a repository?\n```\n\n## Slash Commands\n\n| Command | Description | Example |\n|---------|-------------|---------|\n| `/entity` | Generate domain entity | `@stratix /entity User with email, name` |\n| `/command` | Generate CQRS command | `@stratix /command CreateUser` |\n| `/query` | Generate CQRS query | `@stratix /query GetUserById` |\n| `/vo` | Generate value object | `@stratix /vo Email with validation` |\n| `/repository` | Generate repository | `@stratix /repository UserRepository` |\n| `/context` | Generate bounded context | `@stratix /context Orders` |\n| `/refactor` | Get refactoring suggestions | `@stratix /refactor [code]` |\n| `/explain` | Explain concepts | `@stratix /explain aggregate roots` |\n\n1. **Analyze** - Understands your project structure\n2. **Search** - Finds relevant documentation using semantic search\n3. **Enrich** - Adds Stratix patterns and examples to prompt\n4. **Generate** - GitHub Copilot creates accurate code\n5. **Use** - Copy generated code into your project files\n\n## Knowledge Base\n\nThe extension includes a pre-built, versioned knowledge base:\n\n- **36+ Documents** - Complete Stratix documentation\n- **Auto-Updates** - CI/CD keeps it synchronized\n- **Version Tracking** - Matches framework version\n- **Local Storage** - Fast, privacy-first\n\n### Version Information\n\nCheck your KB version:\n```\nCmd+Shift+P → \"Stratix: Show Knowledge Base Info\"\n```\n\nUpdate manually:\n```\nCmd+Shift+P → \"Stratix: Rebuild Knowledge Base\"\n```\n\n## VS Code Commands\n\n- `Stratix: Open AI Assistant` - Open Copilot Chat\n- `Stratix: Rebuild Knowledge Base` - Rebuild KB from docs\n- `Stratix: Show Knowledge Base Info` - Display version & stats\n\n## License\n\nMIT © [P. Andrés Carvajal](https://github.com/pcarvajal)\n\n## Support\n\n- [Documentation](https://stratix-dev.github.io/stratix/)",
      "metadata": {
        "type": "api",
        "category": "packages",
        "source": "packages/copilot-rag/README.md",
        "title": "@stratix/copilot-rag"
      }
    },
    {
      "id": "package-core",
      "content": "# @stratix/core\n\nCore package for Stratix framework - DDD primitives, abstractions, and interfaces.\n\nThis package combines:\n- **Domain Primitives**: Entity, AggregateRoot, ValueObject, Result Pattern\n- **Abstractions**: Container, CQRS interfaces, Infrastructure interfaces\n- **Plugin & Module System**: Plugin and ContextModule interfaces\n- **AI Agents**: AI agent primitives and abstractions\n\n## Installation\n\n```bash\npnpm add @stratix/core\n```\n\n## What's Included\n\n### Core Building Blocks\n\n- **Entity** - Base class with identity and timestamps\n- **AggregateRoot** - Entity with domain event support\n- **ValueObject** - Immutable value objects base class\n- **EntityId** - Type-safe identifiers with phantom types\n- **Result** - Type-safe error handling without exceptions\n- **DomainEvent** - Base interface for domain events\n- **DomainError** - Base class for domain errors\n\n### AI Agent Building Blocks\n\n- **AIAgent** - Base class for AI agents as domain entities\n- **AgentTool** - Base class for agent tools\n- **LLMProvider** - Interface for LLM provider implementations\n- **MemoryStore** - Interface for agent memory persistence\n\n### Pre-built Value Objects\n\n- **Money** - Monetary values with currency support\n- **Currency** - ISO 4217 currency codes with metadata\n- **Email** - Email address validation\n- **PhoneNumber** - International phone numbers with country calling codes\n- **URL** - URL validation and parsing\n- **UUID** - UUID v4 generation and validation\n- **DateRange** - Date ranges with validation\n- **Percentage** - Percentage values (0-100)\n- **Address** - Physical addresses with country support\n- **CountryRegistry** - ISO 3166-1 country codes and metadata\n- **CountryCallingCodeRegistry** - International dialing codes\n\n## Quick Example\n\n```typescript\nimport { Entity, EntityId } from '@stratix/core';\n\ntype UserId = EntityId<'User'>;\n\nclass User extends Entity<'User'> {\n  constructor(\n    id: UserId,\n    private email: string,\n    private name: string\n  ) {\n    super(id, new Date(), new Date());\n  }\n\n  changeName(newName: string): void {\n    this.name = newName;\n    this.touch();\n  }\n}\n\nconst userId = EntityId.create<'User'>();\nconst user = new User(userId, 'user@example.com', 'John');\n```\n\n## Result Pattern\n\n```typescript\nimport { Result, Success, Failure } from '@stratix/core';\n\nfunction divide(a: number, b: number): Result<number> {\n  if (b === 0) {\n    return Failure.create(new Error('Division by zero'));\n  }\n  return Success.create(a / b);\n}\n\nconst result = divide(10, 2);\nif (result.isSuccess) {\n  console.log(result.value); // 5\n} else {\n  console.error(result.error.message);\n}\n```\n\n## AI Agent Base Class\n\n```typescript\nimport {\n  AIAgent,\n  AgentResult,\n  AgentCapabilities,\n  AgentVersionFactory,\n  EntityId,\n  type ModelConfig,\n} from '@stratix/core';\nimport type { LLMProvider } from '@stratix/core';\n\nclass MyAgent extends AIAgent<InputType, OutputType> {\n  readonly name = 'My Agent';\n  readonly description = 'Description of what this agent does';\n  readonly version = AgentVersionFactory.create('1.0.0');\n  readonly capabilities = [AgentCapabilities.TEXT_GENERATION];\n  readonly model: ModelConfig = {\n    provider: 'openai',\n    model: 'gpt-4',\n    temperature: 0.7,\n    maxTokens: 1000,\n  };\n\n  constructor(private llmProvider: LLMProvider) {\n    const id = EntityId.create<'AIAgent'>();\n    const now = new Date();\n    super(id, now, now);\n  }\n\n  protected async execute(input: InputType): Promise<AgentResult<OutputType>> {\n    // Implementation\n    const output: OutputType = /* ... */;\n    return AgentResult.success(output, {\n      model: this.model.model,\n      totalTokens: 100,\n      cost: 0.001,\n    });\n  }\n}\n```\n\n## Value Objects\n\n### Money and Currency\n\n```typescript\nimport { Money, Currency } from '@stratix/core';\n\n// Using factory methods (recommended)\nconst price = Money.USD(99.99);\nconst discounted = price.multiply(0.8); // $79.99\n\nconst totalResult = price.add(discounted);\nif (totalResult.isSuccess) {\n  console.log(totalResult.value.format()); // \"$179.98\"\n}\n\n// Or using create with Result pattern\nconst priceResult = Money.create(99.99, Currency.USD);\nif (priceResult.isSuccess) {\n  console.log(priceResult.value.format()); // \"$99.99\"\n}\n\nconsole.log(Currency.EUR.symbol); // \"€\"\n```\n\n### Email and URL\n\n```typescript\nimport { Email, URL } from '@stratix/core';\n\nconst email = Email.create('user@example.com');\nconsole.log(email.domain); // \"example.com\"\n\nconst url = URL.create('https://example.com/path');\nconsole.log(url.protocol); // \"https\"\n```\n\n### PhoneNumber with Country Codes\n\n```typescript\nimport { PhoneNumber } from '@stratix/core';\n\nconst phoneResult = PhoneNumber.create('+14155552671');\nif (phoneResult.isSuccess) {\n  const phone = phoneResult.value;\n  console.log(phone.format()); // \"+1 (415) 555-2671\"\n  console.log(phone.countryCode); // \"+1\"\n}\n```\n\n### Date Ranges and Percentages\n\n```typescript\nimport { DateRange, Percentage } from '@stratix/core';\n\nconst rangeResult = DateRange.create(\n  new Date('2024-01-01'),\n  new Date('2024-12-31')\n);\nif (rangeResult.isSuccess) {\n  console.log(rangeResult.value.durationInDays()); // 365\n}\n\nconst discountResult = Percentage.fromPercentage(15);\nif (discountResult.isSuccess) {\n  const discount = discountResult.value;\n  const finalPrice = price.multiply(1 - discount.asDecimal()); // 85% of price\n}\n```\n\n### UUID Generation\n\n```typescript\nimport { UUID } from '@stratix/core';\n\nconst id = UUID.generate();\nconsole.log(id.value); // \"550e8400-e29b-41d4-a716-446655440000\"\n```\n\n## API Reference\n\nFor detailed API documentation, visit [Stratix Documentation](https://github.com/stratix-dev/stratix).\n\n## License\n\nMIT\n",
      "metadata": {
        "type": "api",
        "category": "packages",
        "source": "packages/core/README.md",
        "title": "@stratix/core"
      }
    },
    {
      "id": "package-runtime",
      "content": "# @stratix/runtime\n\nPlugin system and application builder for Stratix.\n\n## Installation\n\n```bash\npnpm add @stratix/runtime\n```\n\n## What's Included\n\n- **ApplicationBuilder** - Fluent API to configure your application\n- **Application** - Main application class with lifecycle management\n- **PluginRegistry** - Plugin registration and dependency resolution\n- **LifecycleManager** - Plugin lifecycle management (initialize, start, stop)\n- **DependencyGraph** - Automatic plugin ordering based on dependencies\n- **DefaultPluginContext** - Context passed to plugins during initialization\n- **Error Types** - Specialized errors for runtime operations\n\n## Core Features\n\n### Application Builder\n\nFluent API for configuring and building Stratix applications:\n\n```typescript\nimport { ApplicationBuilder } from '@stratix/runtime';\nimport { AwilixContainer } from '@stratix/di-awilix';\nimport { ConsoleLogger } from '@stratix/core';\n\nconst app = await ApplicationBuilder.create()\n  .useContainer(new AwilixContainer())\n  .useLogger(new ConsoleLogger())\n  .usePlugin(new DatabasePlugin())\n  .usePlugin(new CachePlugin(), { ttl: 3600 })\n  .build();\n\nawait app.start();\n```\n\n### Plugin Lifecycle\n\nPlugins follow a three-phase lifecycle:\n\n1. **Initialize** - Configure and register services\n2. **Start** - Connect to external resources\n3. **Stop** - Gracefully shutdown in reverse order\n\n```typescript\nimport type { Plugin, PluginContext } from '@stratix/core';\n\nclass DatabasePlugin implements Plugin {\n  readonly metadata = {\n    name: 'database',\n    version: '1.0.0',\n    dependencies: ['logger']\n  };\n\n  async initialize(context: PluginContext): Promise<void> {\n    const config = context.getConfig();\n    context.container.register('database', () => new Database(config));\n  }\n\n  async start(): Promise<void> {\n    // Connect to database\n  }\n\n  async stop(): Promise<void> {\n    // Disconnect from database\n  }\n\n  async healthCheck(): Promise<HealthCheckResult> {\n    // Check database connection\n  }\n}\n```\n\n### Dependency Resolution\n\nPlugins are automatically initialized in dependency order:\n\n```typescript\n// Even though registered out of order, plugins initialize correctly\nconst app = await ApplicationBuilder.create()\n  .useContainer(container)\n  .useLogger(logger)\n  .usePlugin(apiPlugin)        // depends on database\n  .usePlugin(databasePlugin)   // depends on logger\n  .usePlugin(loggerPlugin)     // no dependencies\n  .build();\n\n// Initialization order: logger → database → api\n```\n\n### Health Checks\n\nBuilt-in health monitoring for all plugins:\n\n```typescript\nconst app = await ApplicationBuilder.create()\n  .useContainer(container)\n  .useLogger(logger)\n  .usePlugin(new DatabasePlugin())\n  .usePlugin(new CachePlugin())\n  .build();\n\nawait app.start();\n\n// Check overall application health\nconst health = await app.healthCheck();\nconsole.log(health.status);  // HealthStatus.UP, HealthStatus.DEGRADED, or HealthStatus.DOWN\nconsole.log(health.details); // Individual plugin health status\n```\n\n### Plugin Configuration\n\nConfigure plugins before or after registration:\n\n```typescript\nconst app = await ApplicationBuilder.create()\n  .useContainer(container)\n  .useLogger(logger)\n  .usePlugin(databasePlugin, { host: 'localhost', port: 5432 })\n  .configurePlugin('cache', { ttl: 3600 })\n  .build();\n```\n\n### Multiple Plugin Registration\n\nRegister multiple plugins at once:\n\n```typescript\nconst app = await ApplicationBuilder.create()\n  .useContainer(container)\n  .useLogger(logger)\n  .usePlugins([\n    new LoggerPlugin(),\n    new DatabasePlugin(),\n    new CachePlugin(),\n    new ApiPlugin()\n  ])\n  .build();\n```\n\n## API Reference\n\n### ApplicationBuilder\n\n- `create()` - Creates a new ApplicationBuilder instance\n- `useContainer(container)` - Sets the DI container (required)\n- `useLogger(logger)` - Sets the logger (required)\n- `usePlugin(plugin, config?)` - Registers a plugin with optional configuration\n- `usePlugins(plugins)` - Registers multiple plugins\n- `configurePlugin(name, config)` - Sets configuration for a plugin\n- `build()` - Builds and initializes the application\n- `pluginCount` - Returns the number of registered plugins\n\n### Application\n\n- `start()` - Starts all plugins in dependency order\n- `stop()` - Stops all plugins in reverse dependency order\n- `resolve<T>(token)` - Resolves a service from the DI container\n- `getContainer()` - Gets the DI container\n- `getPlugins()` - Gets all registered plugins\n- `getPlugin(name)` - Gets a plugin by name\n- `getLifecyclePhase()` - Gets the current lifecycle phase\n- `healthCheck()` - Performs health checks on all plugins\n\n### LifecyclePhase\n\nLifecycle phases enum:\n\n- `UNINITIALIZED` - Before initialization\n- `INITIALIZING` - During initialization\n- `INITIALIZED` - After initialization, before start\n- `STARTING` - During start\n- `STARTED` - Running\n- `STOPPING` - During shutdown\n- `STOPPED` - After shutdown\n\n### Error Types\n\n- `RuntimeError` - Base error class\n- `CircularDependencyError` - Circular dependency detected\n- `MissingDependencyError` - Plugin dependency not found\n- `DuplicatePluginError` - Plugin name already registered\n- `PluginLifecycleError` - Plugin lifecycle method failed\n\n## Example: Complete Application\n\n```typescript\nimport { ApplicationBuilder } from '@stratix/runtime';\nimport { AwilixContainer } from '@stratix/di-awilix';\nimport { ConsoleLogger } from '@stratix/core';\n\n// Build application\nconst app = await ApplicationBuilder.create()\n  .useContainer(new AwilixContainer())\n  .useLogger(new ConsoleLogger())\n  .usePlugin(new PostgresPlugin(), {\n    host: 'localhost',\n    port: 5432,\n    database: 'myapp'\n  })\n  .usePlugin(new RedisPlugin(), {\n    host: 'localhost',\n    port: 6379\n  })\n  .build();\n\n// Start application\nawait app.start();\n\n// Application is running\nconsole.log('Phase:', app.getLifecyclePhase()); // STARTED\n\n// Check health\nconst health = await app.healthCheck();\nconsole.log('Health:', health.status);\n\n// Access services via DI container\nconst database = app.resolve('database');\n\n// Graceful shutdown\nprocess.on('SIGTERM', async () => {\n  await app.stop();\n  process.exit(0);\n});\n```\n\n## License\n\nMIT\n",
      "metadata": {
        "type": "api",
        "category": "packages",
        "source": "packages/runtime/README.md",
        "title": "@stratix/runtime"
      }
    },
    {
      "id": "package-testing",
      "content": "# @stratix/testing\n\nComprehensive testing utilities for Stratix applications, with specialized support for AI agents.\n\n## Installation\n\n```bash\npnpm add -D @stratix/testing\n```\n\n## Features\n\n### AI Agent Testing\n\n- **MockLLMProvider** - Mock LLM provider for deterministic agent testing\n- **AgentTester** - High-level testing utility with timeout support\n- **Agent Assertions** - Specialized assertions for agent results\n- **Test Helpers** - Utilities for creating test contexts and IDs\n\n### General Testing\n\n- **TestApplication** - Simplified test application builder\n- **Result Assertions** - Assertions for Result pattern\n- **EntityBuilder** - Fluent API for building test entities\n- **DataFactory** - Generate test data (emails, IDs, dates, etc.)\n\n## Quick Examples\n\n### Testing AI Agents\n\n```typescript\nimport { AgentTester, expectSuccess } from '@stratix/testing';\n\ndescribe('CustomerSupportAgent', () => {\n  let tester: AgentTester;\n\n  beforeEach(() => {\n    tester = new AgentTester();\n  });\n\n  it('should respond to greetings', async () => {\n    const agent = new CustomerSupportAgent(...);\n\n    // Set deterministic mock response\n    tester.setMockResponse({\n      content: 'Hello! How can I help you today?',\n      usage: { promptTokens: 10, completionTokens: 20, totalTokens: 30 }\n    });\n\n    const result = await tester.test(agent, { message: 'Hi' });\n\n    expect(result.passed).toBe(true);\n    expectSuccess(result.result);\n    expect(result.duration).toBeLessThan(1000);\n  });\n});\n```\n\n### Using MockLLMProvider Directly\n\n```typescript\nimport { MockLLMProvider } from '@stratix/testing';\n\nconst mockProvider = new MockLLMProvider();\nmockProvider.setResponse({\n  content: '{\"result\": \"success\"}',\n  usage: { promptTokens: 10, completionTokens: 20, totalTokens: 30 }\n});\n\nconst agent = new MyAgent({ provider: mockProvider });\nconst result = await agent.execute(input);\n\n// Verify calls\nexpect(mockProvider.getCallCount()).toBe(1);\nexpect(mockProvider.getLastCall()).toBeDefined();\n```\n\n### Testing with TestApplication\n\n```typescript\nimport { TestApplication } from '@stratix/testing';\n\ndescribe('Integration Tests', () => {\n  let app: Application;\n\n  beforeEach(async () => {\n    app = await TestApplication.create()\n      .useInMemoryDefaults()\n      .usePlugin(myPlugin)\n      .build();\n\n    await app.start();\n  });\n\n  afterEach(async () => {\n    await app.stop();\n  });\n\n  it('should process commands', async () => {\n    // Test with fully configured app\n  });\n});\n```\n\n### Using Result Assertions\n\n```typescript\nimport { assertSuccess, unwrapSuccess } from '@stratix/testing';\n\nconst result = await commandHandler.execute(command);\n\n// Assert success and throw if failed\nassertSuccess(result);\n\n// Or unwrap value directly\nconst value = unwrapSuccess(result);\nexpect(value.id).toBeDefined();\n```\n\n### Building Test Entities\n\n```typescript\nimport { EntityBuilder } from '@stratix/testing';\n\nconst user = new EntityBuilder(User)\n  .withProps({ email: 'test@example.com', name: 'Test User' })\n  .withId(testUserId)\n  .build();\n\n// Build multiple\nconst users = new EntityBuilder(User)\n  .withProps({ role: 'admin' })\n  .buildMany(5);\n```\n\n### Generating Test Data\n\n```typescript\nimport { DataFactory } from '@stratix/testing';\n\nconst email = DataFactory.email('user'); // user1@example.com\nconst id = DataFactory.entityId<'User'>();\nconst date = DataFactory.date(7); // 7 days ago\nconst status = DataFactory.pick(['active', 'inactive']);\n```\n\n## API Reference\n\n### AgentTester\n\nHigh-level testing utility for AI agents.\n\n```typescript\nclass AgentTester {\n  constructor(options?: TestOptions)\n\n  // Mock configuration\n  setMockResponse(response: MockResponse): void\n  setMockResponses(responses: MockResponse[]): void\n  getMockProvider(): MockLLMProvider\n\n  // Testing\n  test<TInput, TOutput>(\n    agent: AIAgent<TInput, TOutput>,\n    input: TInput,\n    context?: AgentContext\n  ): Promise<TestResult<TOutput>>\n\n  // Assertions\n  assertSuccess<TOutput>(result: TestResult<TOutput>): void\n  assertFailure<TOutput>(result: TestResult<TOutput>): void\n  assertDuration<TOutput>(result: TestResult<TOutput>, maxDuration: number): void\n  assertCallCount(expectedCount: number): void\n\n  // Utilities\n  reset(): void\n}\n```\n\n### MockLLMProvider\n\nMock LLM provider implementing the `LLMProvider` interface.\n\n```typescript\nclass MockLLMProvider implements LLMProvider {\n  // Configuration\n  setResponse(response: MockResponse): void\n  setResponses(responses: MockResponse[]): void\n  addResponse(response: MockResponse): void\n\n  // Inspection\n  getCallHistory(): ReadonlyArray<ChatParams>\n  getLastCall(): ChatParams | undefined\n  getCallCount(): number\n\n  // Utilities\n  reset(): void\n\n  // LLMProvider implementation\n  chat(params: ChatParams): Promise<ChatResponse>\n  streamChat(params: ChatParams): AsyncIterable<ChatChunk>\n  embeddings(params: EmbeddingParams): Promise<EmbeddingResponse>\n}\n```\n\n### Agent Assertions\n\nSpecialized assertions for agent results.\n\n```typescript\n// Success/Failure\nexpectSuccess<T>(result: AgentResult<T>): void\nexpectFailure<T>(result: AgentResult<T>): void\n\n// Data validation\nexpectData<T>(result: AgentResult<T>, expected: T): void\nexpectDataContains<T>(result: AgentResult<T>, expected: Partial<T>): void\n\n// Performance\nexpectCostWithinBudget<T>(result: AgentResult<T>, budget: number): void\nexpectDurationWithinLimit<T>(result: AgentResult<T>, maxDuration: number): void\n\n// Error validation\nexpectErrorContains<T>(result: AgentResult<T>, expectedText: string): void\n\n// Model validation\nexpectModel<T>(result: AgentResult<T>, expectedModel: string): void\n```\n\n### Test Helpers\n\nUtilities for creating test data and running tests.\n\n```typescript\n// Context creation\ncreateTestContext(overrides?: Partial<{\n  userId: string;\n  sessionId: string;\n  environment: 'development' | 'staging' | 'production';\n  metadata: Record<string, unknown>;\n  budget: number;\n}>): AgentContext\n\n// ID creation\ncreateTestAgentId(): AgentId\ncreateDeterministicAgentId(seed: string): AgentId\n\n// Timing utilities\nwait(ms: number): Promise<void>\ncreateTimeout(ms: number, message?: string): Promise<never>\nmeasureTime<T>(fn: () => Promise<T>): Promise<{ result: T; duration: number }>\n\n// Test execution\nrepeatTest<T>(times: number, testFn: (iteration: number) => Promise<T>): Promise<T[]>\nrunInParallel<T>(testFns: Array<() => Promise<T>>): Promise<T[]>\n\n// Assertions\nexpectToReject(promise: Promise<unknown>, expectedError?: string | RegExp): Promise<void>\n```\n\n### Result Assertions\n\nAssertions for the Result pattern.\n\n```typescript\n// Assertions\nassertSuccess<T>(result: Result<T>): void\nassertFailure<T>(result: Result<T>): void\n\n// Unwrapping\nunwrapSuccess<T>(result: Result<T>): T\nunwrapFailure<T>(result: Result<T>): Error\n```\n\n### TestApplication\n\nSimplified application builder for integration tests.\n\n```typescript\nclass TestApplication {\n  static create(): TestApplication\n\n  useInMemoryDefaults(): this\n  useContainer(container: Container): this\n  useLogger(logger: Logger): this\n  usePlugin(plugin: Plugin, config?: unknown): this\n\n  build(): Promise<Application>\n}\n\n// Helper function\ncreateTestApp(): Promise<Application>\n```\n\n### EntityBuilder\n\nFluent API for building test entities.\n\n```typescript\nclass EntityBuilder<E extends Entity<any>> {\n  constructor(EntityClass: new (props: any, id: any) => E)\n\n  withProps(props: Partial<any>): this\n  withId(id: any): this\n  build(): E\n  buildMany(count: number): E[]\n}\n\n// Helper function\nentityBuilder<E extends Entity<any>>(\n  EntityClass: new (props: any, id: any) => E\n): EntityBuilder<E>\n```\n\n### DataFactory\n\nFactory for generating test data.\n\n```typescript\nclass DataFactory {\n  static email(prefix?: string): Email\n  static string(prefix?: string): string\n  static number(min?: number, max?: number): number\n  static entityId<T extends string>(): EntityId<T>\n  static boolean(): boolean\n  static date(daysAgo?: number): Date\n  static pick<T>(array: T[]): T\n  static reset(): void\n}\n```\n\n## Best Practices\n\n### AI Agent Testing\n\n1. **Use MockLLMProvider for unit tests** - Avoid real API calls, keep tests fast and deterministic\n2. **Test multiple conversation turns** - Use `setResponses()` to test multi-turn interactions\n3. **Verify token usage** - Ensure cost tracking works correctly\n4. **Test error scenarios** - Use mock responses with errors to test error handling\n5. **Check call history** - Verify the agent calls the LLM with correct parameters\n\n### Result Pattern Testing\n\n1. **Always assert before accessing values** - Use `assertSuccess()` or `unwrapSuccess()`\n2. **Test both success and failure paths** - Ensure error handling works\n3. **Use type-safe assertions** - TypeScript narrows types after assertions\n\n### Integration Testing\n\n1. **Use TestApplication for full stack tests** - Test with real implementations\n2. **Clean up after tests** - Always call `app.stop()` in afterEach\n3. **Use in-memory defaults** - Faster tests without external dependencies\n4. **Test plugin integration** - Verify plugins work together correctly\n\n## Examples\n\nSee the `examples/` directory in the repository for complete examples:\n\n- `examples/ai-agents/echo-agent/` - Simple agent testing\n- `examples/ai-agents/customer-support/` - Production agent with comprehensive tests\n- `examples/rest-api/` - Integration testing with TestApplication\n\n## License\n\nMIT\n",
      "metadata": {
        "type": "api",
        "category": "packages",
        "source": "packages/testing/README.md",
        "title": "@stratix/testing"
      }
    }
  ]
}