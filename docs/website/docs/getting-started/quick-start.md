# Quick Start

**Get a production-ready application quickly.** Stratix combines speed, modularity, and ease-of-use to deliver enterprise-grade architecture with AI Agents as first-class citizens.

Stratix exists to help development teams build production-ready applications with Domain-Driven Design, CQRS, and AI Agents without sacrificing type safety, testability, or architecture. We're not another LLM wrapper - we treat AI agents as domain entities with the same rigor as your business logic.

## Lightning Fast Setup

```bash
# Create project
stratix new my-app

# Generate complete bounded context
cd my-app
stratix generate context Products --props "name:string,price:number,stock:number"

# Start developing
npm run dev
```

**That's it.** You now have:
- 16 generated files (Entity, Commands, Queries, Handlers, Repository, Events, Plugin)
- Type-safe CQRS architecture
- Dependency injection configured
- Domain-Driven Design patterns (optional but recommended)
- Ready for production scaling

**Note:** DDD patterns (AggregateRoot, ValueObject, DomainEvent) are generated by default but optional. You can use simple entities or partial implementations. Key requirement: keep all domain logic in the domain layer.

**Speed comparison:**
- **Traditional setup**: Hours of manual configuration
- **Stratix CLI**: Minutes with production-grade code
- **Result**: Same quality, drastically faster

---

## Choose Your Architecture

Stratix supports two project structures optimized for different use cases. Choose based on your domain complexity:

### DDD Structure (Default)

**Best for:** Small to medium applications, microservices, single bounded context projects

```bash
stratix new my-app --structure ddd
```

**Generated structure:**
```
my-app/
├── src/
│   ├── domain/              # Business logic (DDD optional but recommended)
│   │   ├── entities/
│   │   ├── value-objects/
│   │   └── repositories/
│   ├── application/         # Use cases
│   │   ├── commands/
│   │   └── queries/
│   └── infrastructure/      # External concerns
│       └── persistence/
```

**When to use:**
- Building a focused microservice
- Single bounded context dominates your domain
- You want a flat, direct structure
- Team prefers traditional layered architecture

**Domain Layer Flexibility:** Stratix provides full DDD primitives, but their use is optional. Whether you use AggregateRoot, simple entities, or a partial DDD approach, the key requirement is keeping all domain logic in the domain layer for proper separation of concerns.

**Example workflow:**
```bash
stratix new order-service --structure ddd --pm pnpm
cd order-service

# Add components to existing layers
stratix g entity Order --props "customerId:string,total:number"
stratix g command CreateOrder --input "customerId:string,items:OrderItem[]"
stratix g query GetOrderById --input "id:string" --output "Order"
stratix g vo Money --props "amount:number,currency:string"
```

### Modular Structure

**Best for:** Modular monoliths, multiple bounded contexts, complex domains, gradual microservice migration

```bash
stratix new my-app --structure modular
```

**Generated structure:**
```
my-app/
├── src/
│   └── contexts/            # Bounded contexts as independent modules
│       ├── products/
│       │   ├── domain/
│       │   ├── application/
│       │   ├── infrastructure/
│       │   └── ProductsContextPlugin.ts  # Auto-wiring
│       ├── orders/
│       │   ├── domain/
│       │   ├── application/
│       │   ├── infrastructure/
│       │   └── OrdersContextPlugin.ts
│       └── customers/
```

**When to use:**
- Building a modular monolith
- Multiple bounded contexts coexist
- Planning microservice extraction later (Strangler Fig Pattern)
- Team organized by business domains
- Need independent module deployment

**Example workflow:**
```bash
stratix new ecommerce-platform --structure modular --pm pnpm
cd ecommerce-platform

# Generate complete contexts (each is independent module with 16 files)
stratix g context Products --props "name:string,price:number,stock:number"
stratix g context Orders --props "customerId:string,total:number,status:string"
stratix g context Customers --props "email:string,name:string,phone:string"

# Result: 48 files, 3 independent modules, ready to scale
```

---

## The Modular Structure Advantage

The real power of modular structure is **architectural evolution without rewrites**:

### Deploy as Monolith

Start with all contexts in a single process:

```typescript
// src/index.ts
import { ApplicationBuilder } from '@stratix/runtime';
import { ProductsContextPlugin } from './contexts/products/ProductsContextPlugin.js';
import { OrdersContextPlugin } from './contexts/orders/OrdersContextPlugin.js';
import { CustomersContextPlugin } from './contexts/customers/CustomersContextPlugin.js';

const app = await ApplicationBuilder.create()
  .usePlugin(new ProductsContextPlugin())
  .usePlugin(new OrdersContextPlugin())
  .usePlugin(new CustomersContextPlugin())
  .build();

await app.start();
```

### Extract to Microservices (Zero Code Changes)

When you need to scale, extract contexts to separate services **without rewriting domain code**:

```typescript
// products-service/src/index.ts
import { ApplicationBuilder } from '@stratix/runtime';
import { ProductsContextPlugin } from './contexts/products/ProductsContextPlugin.js';

const app = await ApplicationBuilder.create()
  .usePlugin(new ProductsContextPlugin())  // Same plugin, zero changes!
  .build();

await app.start();
```

```typescript
// orders-service/src/index.ts
import { ApplicationBuilder } from '@stratix/runtime';
import { OrdersContextPlugin } from './contexts/orders/OrdersContextPlugin.js';

const app = await ApplicationBuilder.create()
  .usePlugin(new OrdersContextPlugin())    // Same plugin, zero changes!
  .build();

await app.start();
```

**The domain code remains identical.** Only infrastructure plugins (databases, message queues) change.

---

## Quick Decision Guide

Choose the right structure for your project:

| Criteria | DDD Structure | Modular Structure |
|----------|--------------|-------------------|
| **Bounded Contexts** | 1-2 | 3+ |
| **Team Size** | 1-5 developers | 5+ developers |
| **Deployment** | Single service | Monolith → Microservices |
| **Complexity** | Low to Medium | Medium to High |
| **Scaling Strategy** | Vertical | Horizontal (gradual) |
| **Learning Curve** | Easier | Moderate |
| **Refactoring Cost** | Medium | Very Low |

**Still unsure?** Start with `--structure ddd`. You can always refactor to modular when you add more contexts.

---

## The Enterprise AI Agent Framework

Stratix treats **AI agents as domain entities**, not service wrappers. Build intelligent applications where AI agents live in your domain layer with full type safety, testability, and production patterns.

### AI Agents as Domain Entities

```typescript
import { AIAgent, AgentResult, AgentContext } from '@stratix/primitives';
import { OpenAIProvider } from '@stratix/ext-ai-agents-openai';

class CustomerSupportAgent extends AIAgent<SupportTicket, SupportResponse> {
  readonly name = 'Customer Support Agent';
  readonly description = 'Handles customer support inquiries';
  readonly version = AgentVersionFactory.create('1.0.0');
  readonly capabilities = ['ticket_routing', 'sentiment_analysis'];
  
  readonly model = {
    provider: 'openai',
    model: 'gpt-4',
    temperature: 0.7,
    maxTokens: 2000
  };

  async execute(ticket: SupportTicket): Promise<AgentResult<SupportResponse>> {
    const context = new AgentContext({
      sessionId: ticket.id,
      environment: 'production',
      budget: 0.50 // USD limit per execution
    });
    
    const result = await this.llmProvider.chat({
      model: this.model.model,
      messages: this.buildMessages(ticket),
      tools: this.getTools()
    });
    
    return AgentResult.success(this.parseResponse(result));
  }
}
```

### Production Patterns Built-In

**Budget enforcement:**
```typescript
const context = new AgentContext({
  sessionId: 'session-123',
  budget: 1.00 // Maximum $1.00 per execution
});

const result = await orchestrator.execute(agent.id, input, context);
console.log('Cost:', result.executionTrace.totalCost); // Automatic tracking
```

**Agent orchestration:**
```typescript
import { StratixAgentOrchestrator } from '@stratix/impl-ai-agents';

const orchestrator = new StratixAgentOrchestrator(
  agentRepository,
  auditLog,
  llmProvider,
  {
    auditEnabled: true,
    budgetEnforcement: true,
    autoRetry: true,
    maxRetries: 3
  }
);

orchestrator.registerAgent(supportAgent);
orchestrator.registerAgent(analysisAgent);
```

**Multi-LLM support:**
```typescript
import { OpenAIProvider } from '@stratix/ext-ai-agents-openai';
import { AnthropicProvider } from '@stratix/ext-ai-agents-anthropic';

// Unified interface, swap providers without changing agent code
const openAI = new OpenAIProvider({ apiKey: process.env.OPENAI_KEY });
const anthropic = new AnthropicProvider({ apiKey: process.env.ANTHROPIC_KEY });
```

**Testing with mock providers:**
```typescript
import { MockLLMProvider } from '@stratix/testing';

const mockProvider = new MockLLMProvider({
  responses: ['Expected response'],
  cost: 0.001
});

const agent = new CustomerSupportAgent(mockProvider);
const result = await agent.execute(testTicket);

// Deterministic tests, no API calls
expect(result.isSuccess).toBe(true);
```

### Why This Matters

**Traditional approach (LLM wrappers):**
- AI logic scattered across service classes
- No type safety for inputs/outputs
- Testing requires expensive API calls
- Budget tracking is manual or missing
- No audit trail or observability

**Stratix approach (First-class citizens):**
- Agents are domain entities following DDD
- Full type safety with `AIAgent<TInput, TOutput>`
- Mock providers for deterministic testing
- Budget enforcement and cost tracking automatic
- Complete audit logging and tracing
- Integrates with CQRS, events, repositories

### Getting Started with AI Agents

```bash
# Add AI provider extensions
stratix add ai-openai
stratix add ai-anthropic

# Agents are entities in your domain layer
# src/domain/agents/CustomerSupportAgent.ts
```

For detailed AI agent documentation, see [AI Agents Guide](../core-concepts/ai-agents.md).

---

## Extensibility with Custom Plugins

Beyond the built-in extensions, Stratix lets you **create and distribute custom plugins** to encapsulate integrations, business logic, or infrastructure concerns.

### Why Custom Plugins?

**Enterprise scenario:** Building a multi-tenant SaaS platform where each client needs different integrations:
- Client A: Stripe + Salesforce + Slack
- Client B: PayPal + HubSpot + Microsoft Teams
- Client C: Square + Dynamics 365 + Email

Instead of conditionals scattered throughout your code, create plugins and compose them per client.

### Creating a Custom Plugin

```bash
# Generate plugin template
stratix g plugin PaymentProcessor
```

**Basic plugin structure:**
```typescript
import { Plugin, PluginContext } from '@stratix/abstractions';

export class PaymentProcessorPlugin implements Plugin {
  name = 'payment-processor';
  version = '1.0.0';
  
  async initialize(context: PluginContext): Promise<void> {
    // Register services with DI container
    context.container.register('paymentService', () => 
      new PaymentService(this.config)
    );
  }
  
  async start(): Promise<void> {
    // Initialize payment gateway
  }
  
  async stop(): Promise<void> {
    // Cleanup
  }
  
  async healthCheck(): Promise<HealthCheckResult> {
    return { healthy: true };
  }
}
```

**Compose per client:**
```typescript
// Client A
const clientAApp = await ApplicationBuilder.create()
  .usePlugin(new StripePlugin(clientA.stripeKey))
  .usePlugin(new SalesforcePlugin(clientA.salesforceKey))
  .usePlugin(new SlackPlugin(clientA.slackWebhook))
  .build();

// Client B - different plugins, same code structure
const clientBApp = await ApplicationBuilder.create()
  .usePlugin(new PayPalPlugin(clientB.paypalKey))
  .usePlugin(new HubSpotPlugin(clientB.hubspotKey))
  .usePlugin(new TeamsPlugin(clientB.teamsWebhook))
  .build();
```

**Benefits:**
- **Reusable**: Write once, use across clients
- **Testable**: Test plugins independently
- **Distributable**: Publish to private npm registry
- **Isolated**: Each plugin manages its own lifecycle

For detailed plugin development guide, see [Plugin Development](../core-concepts/plugins.md).

---

## Real-World Example: E-Commerce Platform

Let's build a complete e-commerce platform with 5 bounded contexts in under 2 minutes:

```bash
# Create modular project
stratix new my-ecommerce --structure modular --pm pnpm
cd my-ecommerce

# Generate all contexts (instantly)
stratix g context Products --props "name:string,price:number,stock:number"
stratix g context Orders --props "customerId:string,total:number,status:string"
stratix g context Payments --props "orderId:string,amount:number,method:string"
stratix g context Shipping --props "orderId:string,address:string,status:string"
stratix g context Customers --props "email:string,name:string,tier:string"

# Result:
# 80+ files generated
# 5 independent bounded contexts
# 15 commands (Create/Update/Delete per context)
# 10 queries (GetById/List per context)
# 5 auto-wired plugins
# Full CQRS + Event Sourcing ready
# Type-safe end-to-end

# Add production extensions
stratix add http validation auth postgres

# Start developing
npm run dev
```

---

## Traditional Application Quick Start

If you prefer step-by-step manual setup, this guide shows building a traditional Stratix application from scratch.

## 1. Create a Project

```bash
pstratix new my-shop
cd my-shop
```

## 2. Create Your First Entity

Create `src/domain/entities/Product.ts`:

```typescript
import { AggregateRoot, EntityId } from '@stratix/primitives';

export type ProductId = EntityId<'Product'>;

export interface ProductProps {
  name: string;
  price: number;
  stock: number;
}

export class Product extends AggregateRoot<'Product'> {
  private constructor(
    id: ProductId,
    private _name: string,
    private _price: number,
    private _stock: number,
    createdAt: Date,
    updatedAt: Date
  ) {
    super(id, createdAt, updatedAt);
  }

  get name(): string {
    return this._name;
  }

  get price(): number {
    return this._price;
  }

  get stock(): number {
    return this._stock;
  }

  static create(props: ProductProps, id?: ProductId): Product {
    // Business validations in domain layer
    if (!props.name || props.name.trim().length === 0) {
      throw new Error('Product name is required');
    }

    if (props.price < 0) {
      throw new Error('Price cannot be negative');
    }

    if (props.stock < 0) {
      throw new Error('Stock cannot be negative');
    }

    const productId = id ?? EntityId.create<'Product'>();
    const now = new Date();
    return new Product(productId, props.name, props.price, props.stock, now, now);
  }

  updateName(name: string): void {
    this._name = name;
    this.touch();
  }

  updatePrice(price: number): void {
    this._price = price;
    this.touch();
  }

  updateStock(stock: number): void {
    this._stock = stock;
    this.touch();
  }
}
```

## 3. Add Domain Events

First, create a domain event for when stock is decreased:

```typescript
// src/domain/events/ProductStockDecreasedEvent.ts
import { DomainEvent } from '@stratix/primitives';
import { ProductId } from '../entities/Product.js';

export class ProductStockDecreasedEvent implements DomainEvent {
  readonly occurredAt: Date;

  constructor(
    public readonly productId: ProductId,
    public readonly quantity: number
  ) {
    this.occurredAt = new Date();
  }
}
```

## 4. Add Business Logic

Now add some domain logic to our `Product`:

```typescript
// src/domain/entities/Product.ts
import { ProductStockDecreasedEvent } from '../events/ProductStockDecreasedEvent.js';

export class Product extends AggregateRoot<'Product'> {
  // ... existing code

  decreaseStock(quantity: number): void {
    if (quantity <= 0) {
      throw new Error('Quantity must be positive');
    }

    if (this._stock < quantity) {
      throw new Error('Insufficient stock');
    }

    this._stock -= quantity;
    this.record(new ProductStockDecreasedEvent(this.id, quantity));
    this.touch();
  }

  isAvailable(): boolean {
    return this._stock > 0;
  }
}
```

## 5. Create a Use Case

Create `src/application/commands/CreateProduct.ts`:

```typescript
import { Command, CommandHandler } from '@stratix/abstractions';
import { Result, Success, Failure } from '@stratix/primitives';
import { Product, ProductId } from '../../domain/entities/Product.js';
import { ProductRepository } from '../../domain/repositories/ProductRepository.js';

export interface CreateProductInput {
  name: string;
  price: number;
  stock: number;
}

export interface CreateProductOutput {
  id: string;
}

export class CreateProduct implements Command {
  constructor(public readonly data: CreateProductInput) {}
}

export class CreateProductHandler implements CommandHandler<CreateProduct, Result<CreateProductOutput>> {
  constructor(private readonly repository: ProductRepository) {}

  async handle(command: CreateProduct): Promise<Result<CreateProductOutput>> {
    try {
      // Domain layer handles all business validations
      const product = Product.create(command.data);

      // Application layer orchestrates persistence
      await this.repository.save(product);

      return Success.create({ id: product.id.toString() });
    } catch (error) {
      return Failure.create(error as Error);
    }
  }
}
```

## 6. Create Repository Interface

Create `src/domain/repositories/ProductRepository.ts`:

```typescript
import { Repository } from '@stratix/abstractions';
import { Product, ProductId } from '../entities/Product.js';

export interface ProductRepository extends Repository<Product, ProductId> {
  // Make base methods required for this repository
  findById(id: ProductId): Promise<Product | null>;
  findAll(): Promise<Product[]>;
  delete(id: ProductId): Promise<void>;

  // Domain-specific query
  findByName(name: string): Promise<Product | null>;
}
```

**Note**: The base `Repository<T, ID>` interface only requires `save()`. All other methods (`findById`, `findAll`, `delete`, `exists`) are optional. You explicitly declare which methods your specific repository needs, making the contract clear and following DDD principles.

## 7. Implement Repository

Create `src/infrastructure/persistence/InMemoryProductRepository.ts`:

```typescript
import { Product, ProductId } from '../../domain/entities/Product.js';
import { ProductRepository } from '../../domain/repositories/ProductRepository.js';

export class InMemoryProductRepository implements ProductRepository {
  private products = new Map<string, Product>();

  async save(product: Product): Promise<void> {
    this.products.set(product.id.toString(), product);
  }

  async findById(id: ProductId): Promise<Product | null> {
    return this.products.get(id.toString()) || null;
  }

  async findByName(name: string): Promise<Product | null> {
    for (const product of this.products.values()) {
      if (product.name === name) {
        return product;
      }
    }
    return null;
  }

  async findAll(): Promise<Product[]> {
    return Array.from(this.products.values());
  }

  async delete(id: ProductId): Promise<void> {
    this.products.delete(id.toString());
  }

  async count(): Promise<number> {
    return this.products.size;
  }
}
```

## 8. Wire Everything Together

Update `src/index.ts`:

```typescript
import { ApplicationBuilder } from '@stratix/runtime';
import { AwilixContainer } from '@stratix/impl-di-awilix';
import { ConsoleLogger, LogLevel, ServiceLifetime } from '@stratix/impl-logger-console';
import { CreateProductHandler } from './application/commands/CreateProduct.js';
import { InMemoryProductRepository } from './infrastructure/persistence/InMemoryProductRepository.js';

async function bootstrap() {
  const container = new AwilixContainer();
  const logger = new ConsoleLogger({ level: LogLevel.INFO });

  // Register dependencies
  const productRepository = new InMemoryProductRepository();
  container.register('productRepository', () => productRepository, { lifetime: ServiceLifetime.SINGLETON });
  container.register('createProductHandler', () => new CreateProductHandler(productRepository), { lifetime: ServiceLifetime.SINGLETON });

  const app = await ApplicationBuilder.create()
    .useContainer(container)
    .useLogger(logger)
    .build();

  await app.start();

  // Example usage
  const handler = container.resolve<CreateProductHandler>('createProductHandler');

  const result = await handler.handle({
    data: {
      name: 'Laptop',
      price: 999.99,
      stock: 10
    }
  });

  if (result.isSuccess) {
    logger.info('Product created!', { productId: result.value.id });
  } else {
    logger.error('Failed to create product', { error: result.error });
  }

  await app.stop();
}

bootstrap().catch(console.error);
```

## 9. Run Your Application

```bash
pnpm run dev
```

You should see:

```
Application started!
[INFO] Product created! { productId: '...' }
```

## Next Steps

Congratulations! You've built your first Stratix application.

### Want to Add AI Agents?

Check out the **AI Agent Starter** template to learn how to integrate AI agents into your application:

```bash
stratix new my-ai-learning -- --template ai-agent-starter
```

### Continue Learning

- [Core Concepts](../core-concepts/architecture.md) - Understand Stratix architecture
- [Entities & Aggregates](../core-concepts/entities.md) - Deep dive into domain modeling
- [CQRS](../core-concepts/cqrs.md) - Commands and Queries
- [Testing](../advanced/testing.md) - Write tests for your application
- [AI Agents](../core-concepts/ai-agents.md) - Build intelligent agents (coming soon)
